/**
 * Search API Route Handler
 * Generated by vai v{{vaiVersion}} on {{generatedAt}}
 * 
 * POST /api/search
 */

import { NextResponse } from 'next/server';
import { embedQuery{{#if rerank}}, rerank{{/if}} } from '@/lib/voyage';
import { vectorSearch } from '@/lib/mongodb';

export async function POST(request) {
  const start = Date.now();
  
  try {
    const body = await request.json();
    const { query, limit = 5, includeContext = false, filter } = body;
    
    if (!query || typeof query !== 'string') {
      return NextResponse.json(
        { error: 'Query is required' },
        { status: 400 }
      );
    }
    
{{#if rerank}}
    const candidates = body.candidates || 20;
{{/if}}
    
    // Step 1: Embed the query
    const queryEmbedding = await embedQuery(query);
    
    // Step 2: Vector search
{{#if rerank}}
    const searchResults = await vectorSearch(queryEmbedding, {
      limit: candidates,
      filter,
    });
{{else}}
    const searchResults = await vectorSearch(queryEmbedding, {
      limit,
      filter,
    });
{{/if}}
    
    if (searchResults.length === 0) {
      return NextResponse.json({
        results: [],
        meta: {
          model: '{{model}}',
          took: Date.now() - start,
        },
      });
    }
    
{{#if rerank}}
    // Step 3: Rerank for better relevance
    const documents = searchResults.map(r => r.document.text);
    const { results: reranked } = await rerank(query, documents, { topK: limit });
    
    const results = reranked.map(r => ({
      text: searchResults[r.index].document.text,
      score: r.relevanceScore,
      metadata: searchResults[r.index].document.metadata,
    }));
{{else}}
    const results = searchResults.map(r => ({
      text: r.document.text,
      score: r.score,
      metadata: r.document.metadata,
    }));
{{/if}}
    
    const response = {
      results,
      meta: {
        model: '{{model}}',
{{#if rerank}}
        rerankModel: '{{rerankModel}}',
{{/if}}
        took: Date.now() - start,
      },
    };
    
    if (includeContext) {
      response.context = results.map(r => r.text).join('\n\n---\n\n');
    }
    
    return NextResponse.json(response);
  } catch (error) {
    console.error('Search error:', error);
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}
