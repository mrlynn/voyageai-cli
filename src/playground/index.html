<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üß≠ Voyage AI Playground</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #1a1a2e;
  --bg-surface: #16213e;
  --bg-card: #1e2a47;
  --bg-input: #0f1629;
  --accent: #00d4aa;
  --accent-dim: #00a88a;
  --accent-glow: rgba(0, 212, 170, 0.15);
  --text: #e0e0e0;
  --text-dim: #8892a4;
  --text-muted: #5a6478;
  --border: #2a3550;
  --error: #ff6b6b;
  --warning: #ffd93d;
  --success: #00d4aa;
  --red: #ff6b6b;
  --yellow: #ffd93d;
  --green: #00d4aa;
  --radius: 8px;
  --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
  --mono: 'SF Mono', 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
}

html, body { height: 100%; }

body {
  font-family: var(--font);
  background: var(--bg);
  color: var(--text);
  line-height: 1.6;
  overflow-x: hidden;
}

/* Nav */
.nav {
  background: var(--bg-surface);
  border-bottom: 1px solid var(--border);
  padding: 0 24px;
  height: 56px;
  display: flex;
  align-items: center;
  gap: 16px;
  position: sticky;
  top: 0;
  z-index: 100;
}

.nav-title {
  font-size: 18px;
  font-weight: 700;
  color: var(--accent);
  white-space: nowrap;
}

.nav-spacer { flex: 1; }

.status-dot {
  width: 8px; height: 8px;
  border-radius: 50%;
  background: var(--text-muted);
  transition: background 0.3s;
}
.status-dot.connected { background: var(--success); box-shadow: 0 0 8px var(--accent-glow); }
.status-dot.error { background: var(--error); }

.status-label {
  font-size: 12px;
  color: var(--text-dim);
}

.nav-model-select {
  background: var(--bg-input);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 6px 12px;
  border-radius: var(--radius);
  font-size: 13px;
  font-family: var(--mono);
  cursor: pointer;
}

/* Tabs */
.tab-bar {
  display: flex;
  background: var(--bg-surface);
  border-bottom: 1px solid var(--border);
  padding: 0 24px;
  gap: 0;
}

.tab-btn {
  background: none;
  border: none;
  color: var(--text-dim);
  padding: 12px 20px;
  font-size: 14px;
  font-family: var(--font);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.2s;
  white-space: nowrap;
}
.tab-btn:hover { color: var(--text); background: rgba(255,255,255,0.03); }
.tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); }

/* Main */
.main { padding: 24px; max-width: 1200px; margin: 0 auto; }

.tab-panel { display: none; }
.tab-panel.active { display: block; }

/* Shared Components */
.card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  margin-bottom: 16px;
}

.card-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

textarea, input[type="text"], input[type="number"] {
  width: 100%;
  background: var(--bg-input);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 10px 14px;
  border-radius: var(--radius);
  font-family: var(--mono);
  font-size: 13px;
  resize: vertical;
  transition: border-color 0.2s;
}
textarea:focus, input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 2px var(--accent-glow);
}

select {
  background: var(--bg-input);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 8px 12px;
  border-radius: var(--radius);
  font-size: 13px;
  font-family: var(--font);
  cursor: pointer;
}
select:focus { outline: none; border-color: var(--accent); }

.btn {
  background: var(--accent);
  color: #0a0a1a;
  border: none;
  padding: 10px 24px;
  border-radius: var(--radius);
  font-size: 14px;
  font-weight: 600;
  font-family: var(--font);
  cursor: pointer;
  transition: all 0.2s;
  display: inline-flex;
  align-items: center;
  gap: 8px;
}
.btn:hover { background: #00eabb; transform: translateY(-1px); }
.btn:active { transform: translateY(0); }
.btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

.btn-secondary {
  background: var(--bg-input);
  color: var(--accent);
  border: 1px solid var(--accent-dim);
}
.btn-secondary:hover { background: var(--accent-glow); }

.btn-small {
  padding: 6px 14px;
  font-size: 12px;
}

.options-row {
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
  margin: 12px 0;
}

.option-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.option-label {
  font-size: 11px;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.error-msg {
  background: rgba(255, 107, 107, 0.1);
  border: 1px solid rgba(255, 107, 107, 0.3);
  color: var(--error);
  padding: 10px 14px;
  border-radius: var(--radius);
  font-size: 13px;
  margin-top: 12px;
  display: none;
}
.error-msg.visible { display: block; }

.spinner {
  display: inline-block;
  width: 16px; height: 16px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }

.result-section {
  margin-top: 16px;
  display: none;
}
.result-section.visible { display: block; }

.stat {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: var(--bg-input);
  padding: 6px 12px;
  border-radius: var(--radius);
  font-size: 13px;
  margin-right: 8px;
  margin-bottom: 8px;
}
.stat-label { color: var(--text-dim); }
.stat-value { color: var(--accent); font-weight: 600; font-family: var(--mono); }

.vector-preview {
  font-family: var(--mono);
  font-size: 12px;
  color: var(--text-dim);
  background: var(--bg-input);
  padding: 12px;
  border-radius: var(--radius);
  overflow-x: auto;
  white-space: nowrap;
  margin-top: 8px;
}

.heatmap {
  height: 24px;
  border-radius: 4px;
  margin-top: 8px;
  overflow: hidden;
  display: flex;
}
.heatmap-bar {
  flex: 1;
  min-width: 1px;
}

/* Compare tab */
.compare-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}

.similarity-display {
  text-align: center;
  padding: 32px 0;
}
.similarity-score {
  font-size: 72px;
  font-weight: 800;
  font-family: var(--mono);
  line-height: 1;
}
.similarity-label {
  font-size: 14px;
  color: var(--text-dim);
  margin-top: 8px;
}
.similarity-bar-outer {
  width: 100%;
  max-width: 400px;
  height: 8px;
  background: var(--bg-input);
  border-radius: 4px;
  margin: 16px auto 0;
  overflow: hidden;
}
.similarity-bar-inner {
  height: 100%;
  border-radius: 4px;
  transition: width 0.6s ease, background 0.6s ease;
}

/* Search tab */
.search-results {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}
.search-results.single-col {
  grid-template-columns: 1fr;
}

.result-item {
  display: flex;
  gap: 12px;
  padding: 12px;
  background: var(--bg-input);
  border-radius: var(--radius);
  margin-bottom: 8px;
  border-left: 3px solid var(--border);
  transition: border-color 0.3s;
}
.result-item.moved-up { border-left-color: var(--green); }
.result-item.moved-down { border-left-color: var(--red); }

.result-rank {
  font-size: 20px;
  font-weight: 700;
  color: var(--accent);
  font-family: var(--mono);
  min-width: 30px;
}
.result-body { flex: 1; min-width: 0; }
.result-text {
  font-size: 13px;
  color: var(--text);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.result-score-bar {
  height: 4px;
  background: var(--bg-surface);
  border-radius: 2px;
  margin-top: 6px;
  overflow: hidden;
}
.result-score-fill {
  height: 100%;
  border-radius: 2px;
  background: var(--accent);
}
.result-score-text {
  font-size: 11px;
  font-family: var(--mono);
  color: var(--text-dim);
  margin-top: 4px;
}
.result-movement {
  font-size: 11px;
  font-family: var(--mono);
  margin-top: 2px;
}

/* Explore tab */
.explore-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 16px;
}

.explore-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  cursor: pointer;
  transition: all 0.2s;
}
.explore-card:hover {
  border-color: var(--accent);
  transform: translateY(-2px);
  box-shadow: 0 4px 20px rgba(0, 212, 170, 0.1);
}
.explore-card.expanded {
  grid-column: 1 / -1;
  cursor: default;
}

.explore-card-icon {
  font-size: 28px;
  margin-bottom: 8px;
}
.explore-card-title {
  font-size: 16px;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 4px;
}
.explore-card-summary {
  font-size: 13px;
  color: var(--text-dim);
}
.explore-card-content {
  display: none;
  margin-top: 16px;
  font-size: 14px;
  line-height: 1.7;
  color: var(--text);
  white-space: pre-wrap;
}
.explore-card.expanded .explore-card-content { display: block; }

.explore-card-actions {
  display: none;
  margin-top: 16px;
  gap: 8px;
}
.explore-card.expanded .explore-card-actions { display: flex; }

/* Benchmark tab */
.bench-panels { display: flex; gap: 8px; margin-bottom: 16px; }
.bench-panel-btn {
  background: var(--bg-input);
  border: 1px solid var(--border);
  color: var(--text-dim);
  padding: 8px 18px;
  border-radius: var(--radius);
  font-size: 13px;
  font-family: var(--font);
  cursor: pointer;
  transition: all 0.2s;
}
.bench-panel-btn:hover { color: var(--text); border-color: var(--text-dim); }
.bench-panel-btn.active { color: var(--accent); border-color: var(--accent); background: var(--accent-glow); }

.bench-view { display: none; }
.bench-view.active { display: block; }

.latency-chart { margin-top: 16px; }
.latency-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
}
.latency-model {
  font-family: var(--mono);
  font-size: 13px;
  min-width: 170px;
  color: var(--text);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.latency-bar-outer {
  flex: 1;
  height: 28px;
  background: var(--bg-input);
  border-radius: 4px;
  overflow: hidden;
  position: relative;
}
.latency-bar-inner {
  height: 100%;
  border-radius: 4px;
  transition: width 0.8s cubic-bezier(0.22, 1, 0.36, 1);
  display: flex;
  align-items: center;
  padding: 0 10px;
  font-family: var(--mono);
  font-size: 12px;
  color: #0a0a1a;
  font-weight: 600;
  white-space: nowrap;
}
.latency-bar-inner.running {
  background: var(--border) !important;
  width: 100% !important;
  animation: pulse-bar 1.2s ease-in-out infinite;
}
@keyframes pulse-bar {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.6; }
}
.latency-stats {
  min-width: 90px;
  font-family: var(--mono);
  font-size: 12px;
  color: var(--text-dim);
  text-align: right;
}
.latency-badge {
  font-size: 14px;
  min-width: 20px;
  text-align: center;
}

/* Ranking diff */
.rank-comparison { margin-top: 16px; }
.rank-row {
  display: grid;
  grid-template-columns: 30px 1fr 40px 1fr;
  gap: 8px;
  align-items: start;
  margin-bottom: 8px;
  padding: 8px;
  background: var(--bg-input);
  border-radius: var(--radius);
}
.rank-num {
  font-size: 16px;
  font-weight: 700;
  color: var(--accent);
  font-family: var(--mono);
  text-align: center;
}
.rank-item {
  font-size: 13px;
  padding: 6px 10px;
  border-radius: 4px;
  border-left: 3px solid var(--border);
}
.rank-item .rank-score {
  font-family: var(--mono);
  font-size: 11px;
  color: var(--text-dim);
  margin-top: 2px;
}
.rank-match { border-left-color: var(--green); }
.rank-differ { border-left-color: var(--yellow); }
.rank-arrow { text-align: center; color: var(--text-muted); font-size: 18px; padding-top: 4px; }

/* Quantization charts */
.quant-charts { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px; }
@media (max-width: 768px) { .quant-charts { grid-template-columns: 1fr; } }

.quant-bar-group { margin-bottom: 14px; }
.quant-bar-label {
  display: flex; justify-content: space-between; align-items: baseline;
  margin-bottom: 4px; font-size: 13px;
}
.quant-bar-label .dtype-name { color: var(--accent); font-weight: 600; font-family: var(--mono); }
.quant-bar-label .dtype-value { color: var(--text-dim); font-family: var(--mono); font-size: 12px; }
.quant-bar-track {
  height: 32px; background: var(--bg-input); border-radius: 6px;
  overflow: hidden; position: relative;
}
.quant-bar-fill {
  height: 100%; border-radius: 6px;
  transition: width 0.8s cubic-bezier(0.22, 1, 0.36, 1);
  display: flex; align-items: center; padding: 0 10px;
  font-family: var(--mono); font-size: 12px; font-weight: 600;
  color: #0a0a1a; white-space: nowrap; min-width: fit-content;
}
.quant-bar-fill.storage { background: linear-gradient(90deg, #00d4aa, #4ecdc4); }
.quant-bar-fill.latency { background: linear-gradient(90deg, #45b7d1, #82aaff); }
.quant-bar-badge {
  position: absolute; right: 10px; top: 50%; transform: translateY(-50%);
  font-size: 12px; color: var(--text-dim); font-family: var(--mono);
}

.quant-quality-meter { margin-bottom: 14px; }
.quant-meter-header {
  display: flex; justify-content: space-between; align-items: center;
  margin-bottom: 6px;
}
.quant-meter-header .dtype-name { color: var(--accent); font-weight: 600; font-family: var(--mono); font-size: 13px; }
.quant-meter-header .verdict-badge {
  font-size: 12px; padding: 2px 8px; border-radius: 10px; font-weight: 600;
}
.quant-meter-header .verdict-badge.perfect { background: rgba(0,212,170,0.15); color: var(--green); }
.quant-meter-header .verdict-badge.good { background: rgba(255,217,61,0.15); color: var(--yellow); }
.quant-meter-header .verdict-badge.degraded { background: rgba(255,107,107,0.15); color: var(--red); }
.quant-meter-track {
  height: 10px; background: var(--bg-input); border-radius: 5px; overflow: hidden;
}
.quant-meter-fill {
  height: 100%; border-radius: 5px;
  transition: width 0.8s cubic-bezier(0.22, 1, 0.36, 1);
}
.quant-meter-fill.perfect { background: linear-gradient(90deg, #00d4aa, #00e4ba); }
.quant-meter-fill.good { background: linear-gradient(90deg, #ffd93d, #ffe066); }
.quant-meter-fill.degraded { background: linear-gradient(90deg, #ff6b6b, #ff8e8e); }
.quant-meter-detail { font-size: 11px; color: var(--text-muted); margin-top: 4px; font-family: var(--mono); }

.quant-rank-cols {
  display: grid; gap: 12px;
}
.quant-rank-col-header {
  font-weight: 600; color: var(--accent); font-size: 13px; font-family: var(--mono);
  margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid var(--border);
}
.quant-rank-item {
  padding: 8px 10px; margin-bottom: 4px; border-radius: 6px;
  font-size: 12px; position: relative; border-left: 3px solid transparent;
  transition: background 0.2s;
}
.quant-rank-item:hover { background: rgba(255,255,255,0.03); }
.quant-rank-item.match { border-left-color: var(--green); background: rgba(0,212,170,0.06); }
.quant-rank-item.differ { border-left-color: var(--red); background: rgba(255,107,107,0.06); }
.quant-rank-item.baseline { border-left-color: var(--border); background: var(--bg-input); }
.quant-rank-pos {
  display: inline-block; width: 22px; height: 22px; line-height: 22px;
  text-align: center; border-radius: 50%; background: var(--bg-surface);
  color: var(--accent); font-weight: 700; font-size: 11px; font-family: var(--mono);
  margin-right: 8px;
}
.quant-rank-score { color: var(--text-muted); font-size: 11px; font-family: var(--mono); margin-top: 3px; }

/* Cost calculator */
.cost-controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px 32px;
  margin-bottom: 20px;
}
.cost-controls-full { grid-column: 1 / -1; }
.cost-slider-row {
  display: flex;
  align-items: center;
  gap: 12px;
}
.cost-slider-label {
  font-size: 12px;
  color: var(--text-dim);
  min-width: 110px;
}
.cost-slider {
  flex: 1;
  -webkit-appearance: none;
  appearance: none;
  height: 6px;
  background: var(--bg-input);
  border-radius: 3px;
  outline: none;
}
.cost-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 18px; height: 18px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  box-shadow: 0 0 8px var(--accent-glow);
}
.cost-slider-value {
  font-family: var(--mono);
  font-size: 13px;
  color: var(--accent);
  min-width: 70px;
  text-align: right;
  font-weight: 600;
}
.cost-mode-toggle {
  display: flex;
  gap: 0;
  border: 1px solid var(--border);
  border-radius: 8px;
  overflow: hidden;
  width: fit-content;
}
.cost-mode-btn {
  padding: 8px 20px;
  background: transparent;
  border: none;
  color: var(--text-dim);
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s;
  font-family: var(--mono);
}
.cost-mode-btn.active {
  background: var(--accent);
  color: var(--bg);
  font-weight: 600;
}
.cost-mode-btn:hover:not(.active) {
  background: rgba(0, 212, 170, 0.1);
  color: var(--text);
}
.cost-select {
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text);
  font-family: var(--mono);
  font-size: 12px;
  padding: 6px 10px;
  min-width: 160px;
}
.cost-select:focus { border-color: var(--accent); outline: none; }
.cost-model-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
}
.cost-model-label {
  font-size: 12px;
  color: var(--text-dim);
  min-width: 110px;
}
.cost-summary {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 12px;
  margin-bottom: 20px;
}
.cost-summary-card {
  background: var(--bg-input);
  border-radius: 8px;
  padding: 14px 16px;
  border: 1px solid var(--border);
}
.cost-summary-label {
  font-size: 11px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 4px;
}
.cost-summary-value {
  font-family: var(--mono);
  font-size: 20px;
  font-weight: 700;
  color: var(--accent);
}
.cost-summary-detail {
  font-size: 11px;
  color: var(--text-dim);
  margin-top: 4px;
  font-family: var(--mono);
}
.cost-strategy-cards {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap: 16px;
  margin-top: 16px;
}
.cost-strategy {
  background: var(--bg-input);
  border-radius: 10px;
  padding: 18px;
  border: 1px solid var(--border);
  transition: border-color 0.2s, box-shadow 0.2s;
  position: relative;
}
.cost-strategy.recommended {
  border-color: var(--accent);
  box-shadow: 0 0 16px var(--accent-glow);
}
.cost-strategy-badge {
  position: absolute;
  top: -10px;
  right: 16px;
  background: var(--accent);
  color: var(--bg);
  font-size: 10px;
  font-weight: 700;
  padding: 3px 10px;
  border-radius: 10px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.cost-strategy-name {
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 12px;
}
.cost-strategy-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 4px 0;
  font-size: 12px;
}
.cost-strategy-row-label { color: var(--text-dim); }
.cost-strategy-row-value { font-family: var(--mono); color: var(--text); font-weight: 500; }
.cost-strategy-total {
  border-top: 1px solid var(--border);
  margin-top: 10px;
  padding-top: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.cost-strategy-total-label { font-size: 13px; font-weight: 600; color: var(--text); }
.cost-strategy-total-value { font-family: var(--mono); font-size: 18px; font-weight: 700; color: var(--accent); }
.cost-savings {
  font-size: 11px;
  color: #4ade80;
  font-weight: 600;
  margin-top: 6px;
  text-align: right;
}
.cost-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 13px;
  margin-top: 12px;
}
.cost-table th {
  text-align: left;
  padding: 8px 12px;
  color: var(--text-dim);
  font-weight: 500;
  border-bottom: 1px solid var(--border);
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.cost-table td {
  padding: 8px 12px;
  border-bottom: 1px solid rgba(42, 53, 80, 0.3);
  font-family: var(--mono);
}
.cost-table tr:hover { background: rgba(0, 212, 170, 0.03); }
.cost-highlight {
  color: var(--accent);
  font-weight: 600;
}
.cost-bar-cell { position: relative; }
.cost-bar {
  position: absolute;
  left: 0; top: 50%;
  transform: translateY(-50%);
  height: 20px;
  background: var(--accent-glow);
  border-radius: 3px;
  transition: width 0.4s ease;
}
.cost-section-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text);
  margin: 20px 0 8px;
  display: flex;
  align-items: center;
  gap: 8px;
}
.cost-tip {
  font-size: 12px;
  color: var(--text-muted);
  background: rgba(0, 212, 170, 0.05);
  border-left: 3px solid var(--accent);
  padding: 10px 14px;
  border-radius: 0 6px 6px 0;
  margin-top: 16px;
}
.cost-help-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 22px; height: 22px;
  border-radius: 50%;
  border: 1.5px solid var(--accent);
  background: transparent;
  color: var(--accent);
  font-size: 13px;
  font-weight: 700;
  cursor: pointer;
  margin-left: 8px;
  transition: all 0.2s;
  vertical-align: middle;
  font-family: var(--mono);
  line-height: 1;
}
.cost-help-btn:hover {
  background: var(--accent);
  color: var(--bg);
  box-shadow: 0 0 10px var(--accent-glow);
}
.cost-modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(4px);
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.25s ease;
}
.cost-modal-overlay.open {
  opacity: 1;
  pointer-events: auto;
}
.cost-modal {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: 14px;
  max-width: 680px;
  width: 90%;
  max-height: 85vh;
  overflow-y: auto;
  padding: 32px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  position: relative;
}
.cost-modal::-webkit-scrollbar { width: 6px; }
.cost-modal::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
.cost-modal-close {
  position: absolute;
  top: 14px; right: 16px;
  background: none;
  border: none;
  color: var(--text-dim);
  font-size: 22px;
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 6px;
  transition: all 0.15s;
}
.cost-modal-close:hover { background: rgba(255,255,255,0.05); color: var(--text); }
.cost-modal h2 {
  font-size: 18px;
  color: var(--text);
  margin: 0 0 20px;
  display: flex;
  align-items: center;
  gap: 10px;
}
.cost-modal h3 {
  font-size: 14px;
  color: var(--accent);
  margin: 22px 0 10px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.cost-modal p, .cost-modal li {
  font-size: 13px;
  color: var(--text-dim);
  line-height: 1.7;
}
.cost-modal ul { padding-left: 20px; margin: 6px 0; }
.cost-modal li { margin-bottom: 4px; }
.cost-modal code {
  background: var(--bg-input);
  padding: 2px 7px;
  border-radius: 4px;
  font-size: 12px;
  color: var(--accent);
  font-family: var(--mono);
}
.cost-modal .formula {
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 14px 18px;
  margin: 10px 0;
  font-family: var(--mono);
  font-size: 13px;
  color: var(--text);
  line-height: 1.8;
}
.cost-modal .formula .label {
  color: var(--text-muted);
  font-size: 11px;
}
.cost-modal .formula .accent { color: var(--accent); font-weight: 600; }
.cost-modal .example {
  background: rgba(0, 212, 170, 0.05);
  border-left: 3px solid var(--accent);
  border-radius: 0 8px 8px 0;
  padding: 12px 16px;
  margin: 12px 0;
  font-size: 12px;
  color: var(--text-dim);
  font-family: var(--mono);
  line-height: 1.8;
}

/* History chart */
.history-empty {
  text-align: center;
  padding: 40px;
  color: var(--text-muted);
  font-size: 14px;
}
.history-chart {
  display: flex;
  align-items: flex-end;
  gap: 4px;
  height: 120px;
  padding: 8px 0;
  border-bottom: 1px solid var(--border);
}
.history-bar-group {
  flex: 1;
  display: flex;
  gap: 2px;
  align-items: flex-end;
  height: 100%;
  min-width: 0;
}
.history-bar {
  flex: 1;
  border-radius: 3px 3px 0 0;
  min-width: 4px;
  transition: height 0.4s ease;
  cursor: pointer;
  position: relative;
}
.history-bar:hover { opacity: 0.8; }
.history-legend {
  display: flex;
  gap: 16px;
  justify-content: center;
  margin-top: 8px;
  font-size: 12px;
  color: var(--text-dim);
}
.history-legend-dot {
  display: inline-block;
  width: 10px; height: 10px;
  border-radius: 2px;
  margin-right: 4px;
  vertical-align: middle;
}
.history-labels {
  display: flex;
  justify-content: space-between;
  font-size: 10px;
  color: var(--text-muted);
  margin-top: 4px;
}

/* About page */
.about-container { max-width: 680px; margin: 0 auto; }
.about-header { display: flex; gap: 24px; align-items: center; margin-bottom: 24px; }
.about-avatar {
  width: 120px; height: 120px;
  border-radius: 50%;
  border: 3px solid var(--accent);
  box-shadow: 0 0 20px var(--accent-glow);
  flex-shrink: 0;
}
.about-name { font-size: 24px; font-weight: 700; color: var(--text); }
.about-role { font-size: 14px; color: var(--accent); margin-top: 4px; }
.about-links { display: flex; gap: 12px; margin-top: 8px; }
.about-links a {
  color: var(--text-dim);
  font-size: 13px;
  text-decoration: none;
  transition: color 0.2s;
}
.about-links a:hover { color: var(--accent); }
.about-section { margin-bottom: 24px; }
.about-section-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--accent);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
}
.about-text { font-size: 14px; line-height: 1.8; color: var(--text); }
.about-text a { color: var(--accent); text-decoration: none; }
.about-text a:hover { text-decoration: underline; }
.about-disclaimer {
  background: rgba(255, 215, 61, 0.08);
  border: 1px solid rgba(255, 215, 61, 0.2);
  border-radius: var(--radius);
  padding: 16px 20px;
  margin-top: 24px;
}
.about-disclaimer-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--warning);
  margin-bottom: 6px;
}
.about-disclaimer-text {
  font-size: 13px;
  line-height: 1.7;
  color: var(--text-dim);
}

@media (max-width: 768px) {
  .compare-grid, .search-results { grid-template-columns: 1fr; }
  .nav { padding: 0 12px; }
  .main { padding: 16px; }
  .tab-btn { padding: 10px 14px; font-size: 13px; }
}
</style>
</head>
<body>

<!-- Nav -->
<nav class="nav">
  <div class="nav-title">üß≠ Voyage AI Playground</div>
  <div class="nav-spacer"></div>
  <div class="option-group">
    <span class="option-label">Default Model</span>
    <select id="globalModel" class="nav-model-select"></select>
  </div>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="status-dot" id="statusDot"></div>
    <span class="status-label" id="statusLabel">Checking...</span>
  </div>
</nav>

<!-- Tabs -->
<div class="tab-bar">
  <button class="tab-btn active" data-tab="embed">‚ö° Embed</button>
  <button class="tab-btn" data-tab="compare">‚öñÔ∏è Compare</button>
  <button class="tab-btn" data-tab="search">üîç Search</button>
  <button class="tab-btn" data-tab="benchmark">‚è± Benchmark</button>
  <button class="tab-btn" data-tab="explore">üìö Explore</button>
  <button class="tab-btn" data-tab="about">‚ÑπÔ∏è About</button>
</div>

<div class="main">

<!-- ========== EMBED TAB ========== -->
<div class="tab-panel active" id="tab-embed">
  <div class="card">
    <div class="card-title">Input Text</div>
    <textarea id="embedInput" rows="5" placeholder="Enter text to embed...">MongoDB Atlas provides powerful vector search capabilities for AI applications.</textarea>
  </div>

  <div class="options-row">
    <div class="option-group">
      <span class="option-label">Model</span>
      <select id="embedModel"></select>
    </div>
    <div class="option-group">
      <span class="option-label">Input Type</span>
      <select id="embedInputType">
        <option value="">None</option>
        <option value="query">Query</option>
        <option value="document">Document</option>
      </select>
    </div>
    <div class="option-group">
      <span class="option-label">Dimensions</span>
      <select id="embedDimensions">
        <option value="">Default</option>
        <option value="256">256</option>
        <option value="512">512</option>
        <option value="1024">1024</option>
        <option value="2048">2048</option>
      </select>
    </div>
    <div class="option-group">
      <span class="option-label">Output Type</span>
      <select id="embedOutputDtype">
        <option value="float">float (32-bit)</option>
        <option value="int8">int8 (4√ó smaller)</option>
        <option value="uint8">uint8 (4√ó smaller)</option>
        <option value="binary">binary (32√ó smaller)</option>
        <option value="ubinary">ubinary (32√ó smaller)</option>
      </select>
    </div>
    <button class="btn" id="embedBtn" onclick="doEmbed()">‚ö° Embed</button>
  </div>

  <div class="error-msg" id="embedError"></div>

  <div class="result-section" id="embedResult">
    <div class="card">
      <div class="card-title">Result</div>
      <div id="embedStats"></div>
      <div class="vector-preview" id="embedVector"></div>
      <div style="margin-top:8px;">
        <button class="btn btn-secondary btn-small" onclick="copyVector()">üìã Copy Full Vector</button>
      </div>
      <div class="card-title" style="margin-top:16px;">Vector Heatmap</div>
      <div class="heatmap" id="embedHeatmap"></div>
    </div>
  </div>
</div>

<!-- ========== COMPARE TAB ========== -->
<div class="tab-panel" id="tab-compare">
  <div class="compare-grid">
    <div class="card">
      <div class="card-title">Text A</div>
      <textarea id="compareA" rows="5" placeholder="Enter first text...">MongoDB is a popular NoSQL database</textarea>
    </div>
    <div class="card">
      <div class="card-title">Text B</div>
      <textarea id="compareB" rows="5" placeholder="Enter second text...">Document databases store data as JSON-like objects</textarea>
    </div>
  </div>

  <div class="options-row">
    <div class="option-group">
      <span class="option-label">Model</span>
      <select id="compareModel"></select>
    </div>
    <div class="option-group">
      <span class="option-label">Dimensions</span>
      <select id="compareDimensions">
        <option value="">Default</option>
        <option value="256">256</option>
        <option value="512">512</option>
        <option value="1024">1024</option>
        <option value="2048">2048</option>
      </select>
    </div>
    <button class="btn" id="compareBtn" onclick="doCompare()">‚öñÔ∏è Compare</button>
  </div>

  <div class="error-msg" id="compareError"></div>

  <div class="result-section" id="compareResult">
    <div class="card">
      <div class="similarity-display">
        <div class="similarity-score" id="simScore">‚Äî</div>
        <div class="similarity-label">Cosine Similarity</div>
        <div class="similarity-bar-outer">
          <div class="similarity-bar-inner" id="simBar" style="width:0%"></div>
        </div>
      </div>
      <div id="compareStats" style="text-align:center;"></div>
    </div>
  </div>
</div>

<!-- ========== SEARCH TAB ========== -->
<div class="tab-panel" id="tab-search">
  <div class="card">
    <div class="card-title">Query</div>
    <input type="text" id="searchQuery" placeholder="Enter your search query..." value="How do I build AI-powered search?">
  </div>

  <div class="card">
    <div class="card-title">Documents (one per line)</div>
    <textarea id="searchDocs" rows="8" placeholder="Enter documents, one per line...">MongoDB Atlas provides vector search capabilities
The recipe calls for two cups of flour and three eggs
Voyage AI embeddings power semantic retrieval for modern applications
Python is a popular programming language for data science
Atlas Search combines full-text and vector search in one platform
Machine learning models can be deployed at the edge
Semantic search understands meaning beyond keyword matching</textarea>
  </div>

  <div class="options-row">
    <div class="option-group">
      <span class="option-label">Embedding Model</span>
      <select id="searchEmbedModel"></select>
    </div>
    <div class="option-group">
      <span class="option-label">Rerank Model</span>
      <select id="searchRerankModel"></select>
    </div>
    <div class="option-group">
      <span class="option-label">Top K</span>
      <select id="searchTopK">
        <option value="3">3</option>
        <option value="5" selected>5</option>
        <option value="10">10</option>
      </select>
    </div>
    <button class="btn" id="searchBtn" onclick="doSearch(false)">üîç Search</button>
    <button class="btn btn-secondary" id="searchRerankBtn" onclick="doSearch(true)">üîç+ Rerank</button>
  </div>

  <div class="error-msg" id="searchError"></div>

  <div class="result-section" id="searchResult">
    <div class="search-results" id="searchResultGrid"></div>
  </div>
</div>

<!-- ========== BENCHMARK TAB ========== -->
<div class="tab-panel" id="tab-benchmark">

  <!-- Sub-panel switcher -->
  <div class="bench-panels">
    <button class="bench-panel-btn active" data-bench="latency">‚ö° Latency</button>
    <button class="bench-panel-btn" data-bench="ranking">üèÜ Ranking</button>
    <button class="bench-panel-btn" data-bench="quantization">‚öóÔ∏è Quantization</button>
    <button class="bench-panel-btn" data-bench="cost">üí∞ Cost</button>
    <button class="bench-panel-btn" data-bench="history">üìä History</button>
  </div>

  <!-- ‚îÄ‚îÄ Latency Panel ‚îÄ‚îÄ -->
  <div class="bench-view active" id="bench-latency">
    <div class="card">
      <div class="card-title">Embedding Latency Benchmark</div>
      <textarea id="benchLatencyInput" rows="3" placeholder="Enter text to benchmark (or leave for built-in sample)..."></textarea>
      <div class="options-row">
        <div class="option-group">
          <span class="option-label">Models</span>
          <div id="benchModelChecks" style="display:flex;gap:8px;flex-wrap:wrap;"></div>
        </div>
        <div class="option-group">
          <span class="option-label">Rounds</span>
          <select id="benchRounds">
            <option value="1">1</option>
            <option value="3" selected>3</option>
            <option value="5">5</option>
            <option value="10">10</option>
          </select>
        </div>
        <button class="btn" id="benchLatencyBtn" onclick="doBenchLatency()">‚ö° Run Benchmark</button>
      </div>
    </div>

    <div class="error-msg" id="benchLatencyError"></div>

    <div class="result-section" id="benchLatencyResult">
      <div class="card">
        <div class="card-title">Results</div>
        <div id="benchLatencyStats"></div>
        <div class="latency-chart" id="benchLatencyChart"></div>
      </div>
    </div>
  </div>

  <!-- ‚îÄ‚îÄ Ranking Panel ‚îÄ‚îÄ -->
  <div class="bench-view" id="bench-ranking">
    <div class="card">
      <div class="card-title">Model Ranking Comparison</div>
      <div style="margin-bottom:12px;">
        <input type="text" id="benchRankQuery" placeholder="Search query..." value="How do I search for similar documents using embeddings?">
      </div>
      <textarea id="benchRankDocs" rows="6" placeholder="Documents (one per line)...">Vector search finds documents by computing similarity between embedding vectors in high-dimensional space.
MongoDB Atlas Vector Search lets you index and query vector embeddings alongside your operational data.
Traditional full-text search uses inverted indexes to match keyword terms in documents.
Cosine similarity measures the angle between two vectors, commonly used for semantic search.
Database sharding distributes data across multiple servers for horizontal scalability.
Embedding models convert text into dense numerical vectors that capture meaning.
Approximate nearest neighbor algorithms like HNSW enable fast similarity search at scale.
Reranking models rescore initial search results to improve relevance ordering.</textarea>
      <div class="options-row">
        <div class="option-group">
          <span class="option-label">Model A</span>
          <select id="benchRankModelA"></select>
        </div>
        <div class="option-group">
          <span class="option-label">Model B</span>
          <select id="benchRankModelB"></select>
        </div>
        <div class="option-group">
          <span class="option-label">Mode</span>
          <select id="benchRankMode">
            <option value="embed">Embedding Similarity</option>
            <option value="rerank">Reranking</option>
          </select>
        </div>
        <div class="option-group">
          <span class="option-label">Top K</span>
          <select id="benchRankTopK">
            <option value="3">3</option>
            <option value="5" selected>5</option>
            <option value="8">8</option>
          </select>
        </div>
        <button class="btn" id="benchRankBtn" onclick="doBenchRanking()">üèÜ Compare Rankings</button>
      </div>
    </div>

    <div class="error-msg" id="benchRankError"></div>

    <div class="result-section" id="benchRankResult">
      <div class="card">
        <div class="card-title">Ranking Comparison</div>
        <div id="benchRankVerdict" style="margin-bottom:12px;font-size:14px;"></div>
        <div class="rank-comparison" id="benchRankGrid"></div>
      </div>
    </div>
  </div>

  <!-- ‚îÄ‚îÄ Quantization Panel ‚îÄ‚îÄ -->
  <div class="bench-view" id="bench-quantization">
    <div class="card">
      <div class="card-title">Quantization Benchmark</div>
      <p style="color:var(--text-dim);font-size:13px;margin-bottom:12px;">
        Compare how different output data types (float, int8, binary) affect storage size and ranking quality.
        Embeds the same corpus with each dtype and measures the tradeoff.
      </p>
      <div class="options-row" style="flex-wrap:wrap;">
        <div class="option-group">
          <span class="option-label">Model</span>
          <select id="quantModel"></select>
        </div>
        <div class="option-group">
          <span class="option-label">Dimensions</span>
          <select id="quantDimensions">
            <option value="">Default</option>
            <option value="256">256</option>
            <option value="512">512</option>
            <option value="1024">1024</option>
            <option value="2048">2048</option>
          </select>
        </div>
        <div class="option-group">
          <span class="option-label">Data Types</span>
          <div id="quantDtypeChecks" style="display:flex;gap:8px;flex-wrap:wrap;">
            <label style="display:flex;align-items:center;gap:4px;font-size:13px;cursor:pointer;color:var(--text);">
              <input type="checkbox" value="float" checked style="accent-color:var(--accent);">float
            </label>
            <label style="display:flex;align-items:center;gap:4px;font-size:13px;cursor:pointer;color:var(--text);">
              <input type="checkbox" value="int8" checked style="accent-color:var(--accent);">int8
            </label>
            <label style="display:flex;align-items:center;gap:4px;font-size:13px;cursor:pointer;color:var(--text);">
              <input type="checkbox" value="uint8" style="accent-color:var(--accent);">uint8
            </label>
            <label style="display:flex;align-items:center;gap:4px;font-size:13px;cursor:pointer;color:var(--text);">
              <input type="checkbox" value="ubinary" checked style="accent-color:var(--accent);">ubinary
            </label>
            <label style="display:flex;align-items:center;gap:4px;font-size:13px;cursor:pointer;color:var(--text);">
              <input type="checkbox" value="binary" style="accent-color:var(--accent);">binary
            </label>
          </div>
        </div>
      </div>
      <div style="margin-top:12px;">
        <span class="option-label">Query</span>
        <input type="text" id="quantQuery" placeholder="Search query..." value="How do I search for similar documents using embeddings?" style="width:100%;margin-bottom:8px;">
      </div>
      <div>
        <span class="option-label">Corpus (one document per line)</span>
        <textarea id="quantCorpus" rows="5" placeholder="Documents to embed...">Vector search finds documents by computing similarity between embedding vectors in high-dimensional space.
MongoDB Atlas Vector Search lets you index and query vector embeddings alongside your operational data.
Traditional full-text search uses inverted indexes to match keyword terms in documents.
Cosine similarity measures the angle between two vectors, commonly used for semantic search.
Database sharding distributes data across multiple servers for horizontal scalability.
Embedding models convert text into dense numerical vectors that capture meaning.
Approximate nearest neighbor algorithms like HNSW enable fast similarity search at scale.
Reranking models rescore initial search results to improve relevance ordering.</textarea>
      </div>
      <div style="margin-top:12px;">
        <button class="btn" id="quantBtn" onclick="doBenchQuantization()">‚öóÔ∏è Run Quantization Benchmark</button>
      </div>
    </div>

    <div class="error-msg" id="quantError"></div>

    <div class="result-section" id="quantResult">
      <div class="quant-charts">
        <div class="card">
          <div class="card-title">üì¶ Storage per Vector</div>
          <div id="quantStorageChart"></div>
        </div>
        <div class="card">
          <div class="card-title">‚è± API Latency</div>
          <div id="quantLatencyChart"></div>
        </div>
      </div>
      <div class="card">
        <div class="card-title">üéØ Ranking Quality vs Float Baseline</div>
        <div id="quantQualityMeters" style="margin-bottom:16px;"></div>
        <div id="quantRankGrid"></div>
      </div>
    </div>
  </div>

  <!-- ‚îÄ‚îÄ Cost Panel ‚îÄ‚îÄ -->
  <div class="bench-view" id="bench-cost">
    <div class="card">
      <div class="card-title">üí∞ RAG Cost Calculator <button class="cost-help-btn" id="costHelpBtn" title="How the math works">?</button></div>

      <!-- Mode toggle -->
      <div style="margin-bottom: 20px;">
        <div class="cost-mode-toggle">
          <button class="cost-mode-btn active" data-mode="simple" id="costModeSimple">Simple</button>
          <button class="cost-mode-btn" data-mode="rag" id="costModeRag">RAG Planner</button>
        </div>
      </div>

      <!-- Simple mode (query cost comparison) -->
      <div id="costSimpleMode">
        <div class="cost-controls cost-controls-full">
          <div class="cost-slider-row">
            <span class="cost-slider-label">Tokens / query</span>
            <input type="range" class="cost-slider" id="costTokens" min="50" max="5000" value="500" step="50">
            <span class="cost-slider-value" id="costTokensValue">500</span>
          </div>
          <div class="cost-slider-row">
            <span class="cost-slider-label">Queries / day</span>
            <input type="range" class="cost-slider" id="costQueries" min="10" max="500000" value="1000" step="10">
            <span class="cost-slider-value" id="costQueriesValue">1,000</span>
          </div>
        </div>
        <table class="cost-table" id="costTable">
          <thead>
            <tr>
              <th>Model</th>
              <th>Type</th>
              <th>$/1M tokens</th>
              <th>Daily Cost</th>
              <th>Monthly Cost</th>
              <th style="width:30%">Relative</th>
            </tr>
          </thead>
          <tbody id="costTableBody"></tbody>
        </table>
      </div>

      <!-- RAG Planner mode (full TCO) -->
      <div id="costRagMode" style="display:none;">
        <div class="cost-section-title">üìÑ Documents (one-time ingestion)</div>
        <div class="cost-controls">
          <div class="cost-slider-row">
            <span class="cost-slider-label">Documents</span>
            <input type="range" class="cost-slider" id="ragDocs" min="1000" max="10000000" value="100000" step="1000">
            <span class="cost-slider-value" id="ragDocsValue">100K</span>
          </div>
          <div class="cost-slider-row">
            <span class="cost-slider-label">Tokens / doc</span>
            <input type="range" class="cost-slider" id="ragDocTokens" min="50" max="5000" value="500" step="50">
            <span class="cost-slider-value" id="ragDocTokensValue">500</span>
          </div>
        </div>

        <div class="cost-section-title">üîç Queries (recurring)</div>
        <div class="cost-controls">
          <div class="cost-slider-row">
            <span class="cost-slider-label">Queries / month</span>
            <input type="range" class="cost-slider" id="ragQueries" min="1000" max="50000000" value="1000000" step="1000">
            <span class="cost-slider-value" id="ragQueriesValue">1M</span>
          </div>
          <div class="cost-slider-row">
            <span class="cost-slider-label">Tokens / query</span>
            <input type="range" class="cost-slider" id="ragQueryTokens" min="10" max="500" value="30" step="5">
            <span class="cost-slider-value" id="ragQueryTokensValue">30</span>
          </div>
        </div>

        <div class="cost-section-title">‚öôÔ∏è Configuration</div>
        <div class="cost-controls">
          <div class="cost-model-row">
            <span class="cost-model-label">Doc model</span>
            <select class="cost-select" id="ragDocModel"></select>
          </div>
          <div class="cost-model-row">
            <span class="cost-model-label">Query model</span>
            <select class="cost-select" id="ragQueryModel"></select>
          </div>
          <div class="cost-slider-row">
            <span class="cost-slider-label">Projection</span>
            <input type="range" class="cost-slider" id="ragMonths" min="1" max="36" value="12" step="1">
            <span class="cost-slider-value" id="ragMonthsValue">12 mo</span>
          </div>
        </div>

        <!-- Summary cards -->
        <div class="cost-summary" id="ragSummary"></div>

        <!-- Strategy comparison -->
        <div class="cost-section-title">üìä Strategy Comparison</div>
        <div class="cost-strategy-cards" id="ragStrategies"></div>

        <!-- Per-model table -->
        <div class="cost-section-title">üìã Per-Model Breakdown</div>
        <table class="cost-table" id="ragTable">
          <thead>
            <tr>
              <th>Model</th>
              <th>Doc Cost</th>
              <th>Query $/mo</th>
              <th>Total (projected)</th>
              <th style="width:25%">Relative</th>
            </tr>
          </thead>
          <tbody id="ragTableBody"></tbody>
        </table>

        <div class="cost-tip" id="ragTip"></div>
      </div>
    </div>
  </div>

  <!-- ‚îÄ‚îÄ History Panel ‚îÄ‚îÄ -->
  <div class="bench-view" id="bench-history">
    <div class="card">
      <div class="card-title">Benchmark History</div>
      <div id="benchHistoryContent">
        <div class="history-empty">No benchmarks recorded yet. Run a latency benchmark to start tracking.</div>
      </div>
      <div style="margin-top:12px;text-align:right;">
        <button class="btn btn-secondary btn-small" onclick="clearHistory()">üóë Clear History</button>
      </div>
    </div>
  </div>

</div>

<!-- ========== ABOUT TAB ========== -->
<div class="tab-panel" id="tab-about">
  <div class="about-container">
    <div class="card">
      <div class="about-header">
        <img src="https://avatars.githubusercontent.com/u/192552?v=4" alt="Michael Lynn" class="about-avatar">
        <div>
          <div class="about-name">Michael Lynn</div>
          <div class="about-role">Principal Staff Developer Advocate ¬∑ MongoDB</div>
          <div class="about-links">
            <a href="https://github.com/mrlynn" target="_blank" rel="noopener">üîó GitHub</a>
            <a href="https://mlynn.org" target="_blank" rel="noopener">üåê mlynn.org</a>
            <a href="https://www.npmjs.com/package/voyageai-cli" target="_blank" rel="noopener">üì¶ npm</a>
          </div>
        </div>
      </div>

      <div class="about-section">
        <div class="about-section-title">About This Project</div>
        <div class="about-text">
          <strong>voyageai-cli</strong> (<code style="color:var(--accent);">vai</code>) is a community-built command-line tool for working with
          <a href="https://www.mongodb.com/docs/voyageai/" target="_blank">Voyage AI</a> embeddings, reranking, and
          <a href="https://www.mongodb.com/products/platform/atlas-vector-search" target="_blank">MongoDB Atlas Vector Search</a>.
          It was created to make it easier for developers to explore, benchmark, and integrate
          Voyage AI models into their applications ‚Äî right from the terminal or this playground.
        </div>
      </div>

      <div class="about-section">
        <div class="about-section-title">About Michael</div>
        <div class="about-text">
          Michael Lynn is a Principal Staff Developer Advocate at MongoDB with 25+ years in enterprise
          infrastructure and over a decade at MongoDB. He focuses on strategic developer relations,
          creating educational content around Vector Search, AI enablement, and developer tooling.
          He builds tools like this to help developers get hands-on with new technology faster.
        </div>
      </div>

      <div class="about-section">
        <div class="about-section-title">What You Can Do Here</div>
        <div class="about-text">
          <strong>‚ö° Embed</strong> ‚Äî Generate vector embeddings for any text<br>
          <strong>‚öñÔ∏è Compare</strong> ‚Äî Measure cosine similarity between texts<br>
          <strong>üîç Search</strong> ‚Äî Semantic search with optional reranking<br>
          <strong>‚è± Benchmark</strong> ‚Äî Compare model latency, ranking quality, and costs<br>
          <strong>üìö Explore</strong> ‚Äî Learn about embeddings, vector search, RAG, and more
        </div>
      </div>

      <div class="about-disclaimer">
        <div class="about-disclaimer-title">‚ö†Ô∏è Community Tool Disclaimer</div>
        <div class="about-disclaimer-text">
          This tool is <strong>not</strong> an official product of MongoDB, Inc. or Voyage AI.
          It is independently built and maintained by Michael Lynn as a community resource.
          It is not supported, endorsed, or guaranteed by either company. Use at your own discretion.
          For official documentation, visit
          <a href="https://www.mongodb.com/docs/voyageai/" target="_blank" style="color:var(--warning);">mongodb.com/docs/voyageai</a>.
        </div>
      </div>
    </div>

    <div style="text-align:center;margin-top:16px;font-size:12px;color:var(--text-muted);">
      Made with ‚òï and curiosity ¬∑ <a href="https://github.com/mrlynn/voyageai-cli" target="_blank" style="color:var(--text-dim);">Source on GitHub</a>
    </div>
  </div>
</div>

<!-- ========== EXPLORE TAB ========== -->
<div class="tab-panel" id="tab-explore">
  <div style="margin-bottom:16px;">
    <input type="text" id="exploreSearch" placeholder="üîç Search concepts..." oninput="filterExplore()" style="max-width:400px;">
  </div>
  <div class="explore-grid" id="exploreGrid"></div>
</div>

</div><!-- .main -->

<script>
(function() {
'use strict';

// ‚îÄ‚îÄ State ‚îÄ‚îÄ
let allModels = [];
let embedModels = [];
let rerankModels = [];
let lastEmbedding = null;

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ
async function init() {
  setupTabs();
  await loadConfig();
  await Promise.all([loadModels(), loadConcepts()]);
  populateModelSelects();
  buildExploreCards();
}

// ‚îÄ‚îÄ Tabs ‚îÄ‚îÄ
function setupTabs() {
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
    });
  });
}

function switchTab(tab) {
  document.querySelectorAll('.tab-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.tab === tab);
  });
  document.querySelectorAll('.tab-panel').forEach(p => {
    p.classList.toggle('active', p.id === 'tab-' + tab);
  });
}

// ‚îÄ‚îÄ Config ‚îÄ‚îÄ
async function loadConfig() {
  try {
    const res = await fetch('/api/config');
    const data = await res.json();
    const dot = document.getElementById('statusDot');
    const label = document.getElementById('statusLabel');
    if (data.hasKey) {
      dot.className = 'status-dot connected';
      label.textContent = 'Connected';
    } else {
      dot.className = 'status-dot error';
      label.textContent = 'No API Key';
    }
  } catch {
    document.getElementById('statusDot').className = 'status-dot error';
    document.getElementById('statusLabel').textContent = 'Error';
  }
}

// ‚îÄ‚îÄ Models ‚îÄ‚îÄ
async function loadModels() {
  try {
    const res = await fetch('/api/models');
    const data = await res.json();
    allModels = data.models || [];
    embedModels = allModels.filter(m => m.type === 'embedding');
    rerankModels = allModels.filter(m => m.type === 'reranking');
  } catch {
    console.error('Failed to load models');
  }
}

function populateModelSelects() {
  const saved = localStorage.getItem('vai-playground-model');
  const embedSelects = ['globalModel', 'embedModel', 'compareModel', 'searchEmbedModel'];
  embedSelects.forEach(id => {
    const sel = document.getElementById(id);
    sel.innerHTML = '';
    embedModels.forEach(m => {
      const opt = document.createElement('option');
      opt.value = m.name;
      opt.textContent = m.name + ' ‚Äî ' + m.shortFor;
      sel.appendChild(opt);
    });
    if (saved) sel.value = saved;
  });

  const rerankSel = document.getElementById('searchRerankModel');
  rerankSel.innerHTML = '';
  rerankModels.forEach(m => {
    const opt = document.createElement('option');
    opt.value = m.name;
    opt.textContent = m.name + ' ‚Äî ' + m.shortFor;
    rerankSel.appendChild(opt);
  });

  // Sync global model to others
  document.getElementById('globalModel').addEventListener('change', function() {
    const v = this.value;
    localStorage.setItem('vai-playground-model', v);
    ['embedModel', 'compareModel', 'searchEmbedModel'].forEach(id => {
      document.getElementById(id).value = v;
    });
  });
}

// ‚îÄ‚îÄ API Helpers ‚îÄ‚îÄ
function formatBytesUI(bytes) {
  if (bytes >= 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  if (bytes >= 1024) return (bytes / 1024).toFixed(1) + ' KB';
  return bytes + ' B';
}

async function apiPost(url, body) {
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });
  const data = await res.json();
  if (!res.ok) throw new Error(data.error || data.detail || 'API error');
  return data;
}

function showError(id, msg) {
  const el = document.getElementById(id);
  el.textContent = '‚ö† ' + msg;
  el.classList.add('visible');
}

function hideError(id) {
  document.getElementById(id).classList.remove('visible');
}

function setLoading(btnId, loading) {
  const btn = document.getElementById(btnId);
  if (loading) {
    btn.disabled = true;
    btn._origHTML = btn.innerHTML;
    btn.innerHTML = '<span class="spinner"></span> Working...';
  } else {
    btn.disabled = false;
    btn.innerHTML = btn._origHTML || btn.innerHTML;
  }
}

// ‚îÄ‚îÄ Embed ‚îÄ‚îÄ
window.doEmbed = async function() {
  hideError('embedError');
  const text = document.getElementById('embedInput').value.trim();
  if (!text) { showError('embedError', 'Enter some text to embed'); return; }

  setLoading('embedBtn', true);
  try {
    const model = document.getElementById('embedModel').value;
    const inputType = document.getElementById('embedInputType').value || undefined;
    const dims = document.getElementById('embedDimensions').value;
    const dimensions = dims ? parseInt(dims, 10) : undefined;

    const outputDtype = document.getElementById('embedOutputDtype').value;
    const body = { texts: [text], model, inputType, dimensions };
    if (outputDtype && outputDtype !== 'float') body.output_dtype = outputDtype;

    const data = await apiPost('/api/embed', body);
    const emb = data.data[0].embedding;
    lastEmbedding = emb;

    // Stats
    const dtype = outputDtype || 'float';
    const bytesPerDim = (dtype === 'binary' || dtype === 'ubinary') ? 0.125 : (dtype === 'int8' || dtype === 'uint8') ? 1 : 4;
    const totalBytes = emb.length * bytesPerDim;
    const storageLine = dtype !== 'float'
      ? `<br><span style="color:var(--success)">üì¶ ${dtype}: ${formatBytesUI(totalBytes)}/vector (${(4 * emb.length / totalBytes).toFixed(0)}√ó smaller than float)</span>`
      : '';

    const statsEl = document.getElementById('embedStats');
    statsEl.innerHTML = `
      <span class="stat"><span class="stat-label">Model</span><span class="stat-value">${data.model}</span></span>
      <span class="stat"><span class="stat-label">Dimensions</span><span class="stat-value">${emb.length}</span></span>
      <span class="stat"><span class="stat-label">Tokens</span><span class="stat-value">${data.usage?.total_tokens || '‚Äî'}</span></span>
      <span class="stat"><span class="stat-label">Type</span><span class="stat-value">${dtype}</span></span>
      ${storageLine}
    `;

    // Vector preview
    const preview = emb.slice(0, 20).map(v => v.toFixed(6)).join(', ');
    document.getElementById('embedVector').textContent = `[${preview}, ... ] (${emb.length} values)`;

    // Heatmap
    buildHeatmap(emb, document.getElementById('embedHeatmap'));

    document.getElementById('embedResult').classList.add('visible');
  } catch (err) {
    showError('embedError', err.message);
  } finally {
    setLoading('embedBtn', false);
  }
};

window.copyVector = function() {
  if (!lastEmbedding) return;
  navigator.clipboard.writeText(JSON.stringify(lastEmbedding)).then(() => {
    const btn = document.querySelector('[onclick="copyVector()"]');
    const orig = btn.textContent;
    btn.textContent = '‚úÖ Copied!';
    setTimeout(() => btn.textContent = orig, 1500);
  });
};

function buildHeatmap(vec, container) {
  container.innerHTML = '';
  // Sample down to ~200 bars for visual
  const step = Math.max(1, Math.floor(vec.length / 200));
  const sampled = [];
  for (let i = 0; i < vec.length; i += step) sampled.push(vec[i]);

  const min = Math.min(...sampled);
  const max = Math.max(...sampled);
  const range = max - min || 1;

  sampled.forEach(v => {
    const bar = document.createElement('div');
    bar.className = 'heatmap-bar';
    const norm = (v - min) / range; // 0-1
    const h = Math.round(norm * 160); // hue: 0=red, 80=yellow-green, 160=cyan/teal
    bar.style.background = `hsl(${h}, 80%, 50%)`;
    container.appendChild(bar);
  });
}

// ‚îÄ‚îÄ Compare ‚îÄ‚îÄ
window.doCompare = async function() {
  hideError('compareError');
  const a = document.getElementById('compareA').value.trim();
  const b = document.getElementById('compareB').value.trim();
  if (!a || !b) { showError('compareError', 'Enter text in both fields'); return; }

  setLoading('compareBtn', true);
  try {
    const model = document.getElementById('compareModel').value;
    const dims = document.getElementById('compareDimensions').value;
    const dimensions = dims ? parseInt(dims, 10) : undefined;

    const data = await apiPost('/api/similarity', { texts: [a, b], model, dimensions });
    const sim = data.matrix[0][1];
    const pct = Math.max(0, sim * 100);

    // Color
    let color;
    if (sim > 0.7) color = 'var(--green)';
    else if (sim > 0.4) color = 'var(--yellow)';
    else color = 'var(--red)';

    const scoreEl = document.getElementById('simScore');
    scoreEl.textContent = sim.toFixed(4);
    scoreEl.style.color = color;

    const barEl = document.getElementById('simBar');
    barEl.style.width = pct + '%';
    barEl.style.background = color;

    // Stats
    const statsEl = document.getElementById('compareStats');
    statsEl.innerHTML = `
      <span class="stat"><span class="stat-label">Model</span><span class="stat-value">${data.model}</span></span>
      <span class="stat"><span class="stat-label">Tokens</span><span class="stat-value">${data.usage?.total_tokens || '‚Äî'}</span></span>
    `;

    document.getElementById('compareResult').classList.add('visible');
  } catch (err) {
    showError('compareError', err.message);
  } finally {
    setLoading('compareBtn', false);
  }
};

// ‚îÄ‚îÄ Search ‚îÄ‚îÄ
window.doSearch = async function(withRerank) {
  hideError('searchError');
  const query = document.getElementById('searchQuery').value.trim();
  const docsText = document.getElementById('searchDocs').value.trim();
  if (!query || !docsText) { showError('searchError', 'Enter a query and documents'); return; }

  const documents = docsText.split('\n').map(d => d.trim()).filter(d => d);
  if (documents.length < 2) { showError('searchError', 'Enter at least 2 documents'); return; }

  const btnId = withRerank ? 'searchRerankBtn' : 'searchBtn';
  setLoading('searchBtn', true);
  setLoading('searchRerankBtn', true);

  try {
    const embedModel = document.getElementById('searchEmbedModel').value;
    const topK = parseInt(document.getElementById('searchTopK').value, 10);

    // Embed query + docs
    const allTexts = [query, ...documents];
    const embedData = await apiPost('/api/embed', { texts: allTexts, model: embedModel });
    const vecs = embedData.data.map(d => d.embedding);
    const queryVec = vecs[0];
    const docVecs = vecs.slice(1);

    // Compute similarity
    const scores = docVecs.map((dv, i) => ({
      index: i,
      text: documents[i],
      score: cosineSim(queryVec, dv),
    }));
    scores.sort((a, b) => b.score - a.score);
    const embeddingResults = scores.slice(0, topK);

    let rerankResults = null;
    if (withRerank) {
      const rerankModel = document.getElementById('searchRerankModel').value;
      const rerankData = await apiPost('/api/rerank', { query, documents, model: rerankModel, topK });
      rerankResults = rerankData.data.map(r => ({
        index: r.index,
        text: documents[r.index],
        score: r.relevance_score,
      }));
    }

    renderSearchResults(embeddingResults, rerankResults);
    document.getElementById('searchResult').classList.add('visible');
  } catch (err) {
    showError('searchError', err.message);
  } finally {
    setLoading('searchBtn', false);
    setLoading('searchRerankBtn', false);
  }
};

function cosineSim(a, b) {
  let dot = 0, normA = 0, normB = 0;
  for (let i = 0; i < a.length; i++) {
    dot += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }
  return dot / (Math.sqrt(normA) * Math.sqrt(normB));
}

function renderSearchResults(embResults, rerankResults) {
  const grid = document.getElementById('searchResultGrid');
  grid.innerHTML = '';
  grid.className = rerankResults ? 'search-results' : 'search-results single-col';

  const maxEmbScore = Math.max(...embResults.map(r => r.score));

  // Embedding column
  const embCol = document.createElement('div');
  embCol.innerHTML = '<div class="card-title">Embedding Search</div>';
  embResults.forEach((r, i) => {
    embCol.appendChild(createResultItem(i + 1, r, maxEmbScore));
  });
  grid.appendChild(embCol);

  // Rerank column
  if (rerankResults) {
    const maxRerankScore = Math.max(...rerankResults.map(r => r.score));
    const embRankMap = {};
    embResults.forEach((r, i) => { embRankMap[r.index] = i + 1; });

    const rerankCol = document.createElement('div');
    rerankCol.innerHTML = '<div class="card-title">After Reranking</div>';
    rerankResults.forEach((r, i) => {
      const newRank = i + 1;
      const oldRank = embRankMap[r.index];
      const movement = oldRank !== undefined ? oldRank - newRank : 0;
      rerankCol.appendChild(createResultItem(newRank, r, maxRerankScore, movement));
    });
    grid.appendChild(rerankCol);
  }
}

function createResultItem(rank, result, maxScore, movement) {
  const item = document.createElement('div');
  let moveClass = '';
  if (movement > 0) moveClass = ' moved-up';
  else if (movement < 0) moveClass = ' moved-down';

  const pct = maxScore > 0 ? (result.score / maxScore * 100) : 0;
  const truncText = result.text.length > 80 ? result.text.slice(0, 77) + '...' : result.text;
  let moveHTML = '';
  if (movement !== undefined && movement !== 0) {
    const arrow = movement > 0 ? '‚Üë' : '‚Üì';
    const color = movement > 0 ? 'var(--green)' : 'var(--red)';
    moveHTML = `<div class="result-movement" style="color:${color}">${arrow}${Math.abs(movement)}</div>`;
  }

  item.className = 'result-item' + moveClass;
  item.innerHTML = `
    <div class="result-rank">#${rank}</div>
    <div class="result-body">
      <div class="result-text" title="${result.text.replace(/"/g, '&quot;')}">${truncText}</div>
      <div class="result-score-bar"><div class="result-score-fill" style="width:${pct}%"></div></div>
      <div class="result-score-text">${result.score.toFixed(4)}</div>
      ${moveHTML}
    </div>
  `;
  return item;
}

// ‚îÄ‚îÄ Explore ‚îÄ‚îÄ
// ‚îÄ‚îÄ Explore: icons and tab mappings per concept ‚îÄ‚îÄ
const CONCEPT_META = {
  embeddings:          { icon: 'üßÆ', tab: 'embed' },
  reranking:           { icon: 'üèÜ', tab: 'search' },
  'vector-search':     { icon: 'üîé', tab: 'search' },
  rag:                 { icon: 'ü§ñ', tab: 'search' },
  'cosine-similarity': { icon: 'üìê', tab: 'compare' },
  'two-stage-retrieval': { icon: 'üéØ', tab: 'search' },
  'input-type':        { icon: 'üè∑Ô∏è', tab: 'embed' },
  models:              { icon: 'üß†', tab: 'embed' },
  'api-keys':          { icon: 'üîë', tab: 'embed' },
  'api-access':        { icon: 'üåê', tab: 'embed' },
  'batch-processing':  { icon: 'üì¶', tab: 'embed' },
  benchmarking:        { icon: '‚è±', tab: 'benchmark' },
  quantization:        { icon: '‚öóÔ∏è', tab: 'benchmark' },
};

let exploreConcepts = {};

async function loadConcepts() {
  try {
    const res = await fetch('/api/concepts');
    const data = await res.json();
    exploreConcepts = data.concepts || {};
  } catch {
    console.error('Failed to load concepts');
  }
}

function escapeHtml(str) {
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

function buildExploreCards() {
  const grid = document.getElementById('exploreGrid');
  grid.innerHTML = '';

  for (const [key, concept] of Object.entries(exploreConcepts)) {
    const meta = CONCEPT_META[key] || { icon: 'üìö', tab: 'embed' };
    const card = document.createElement('div');
    card.className = 'explore-card';
    card.dataset.key = key;

    // Build links HTML
    let linksHtml = '';
    if (concept.links && concept.links.length > 0) {
      linksHtml = '<div style="margin-top:12px;"><strong style="color:var(--accent);font-size:12px;">LEARN MORE</strong><br>' +
        concept.links.map(url => `<a href="${escapeHtml(url)}" target="_blank" rel="noopener" style="color:var(--accent);font-size:12px;word-break:break-all;">${escapeHtml(url)}</a>`).join('<br>') +
        '</div>';
    }

    // Build try-it HTML
    let tryItHtml = '';
    if (concept.tryIt && concept.tryIt.length > 0) {
      tryItHtml = '<div style="margin-top:12px;"><strong style="color:var(--accent);font-size:12px;">TRY IT</strong>' +
        concept.tryIt.map(cmd => `<div style="font-family:var(--mono);font-size:12px;color:var(--text-dim);background:var(--bg);padding:4px 8px;border-radius:4px;margin-top:4px;">$ ${escapeHtml(cmd)}</div>`).join('') +
        '</div>';
    }

    card.innerHTML = `
      <div class="explore-card-icon">${meta.icon}</div>
      <div class="explore-card-title">${escapeHtml(concept.title)}</div>
      <div class="explore-card-summary">${escapeHtml(concept.summary)}</div>
      <div class="explore-card-content">${escapeHtml(concept.content)}${linksHtml}${tryItHtml}</div>
      <div class="explore-card-actions">
        <button class="btn btn-small" onclick="tryTopic('${escapeHtml(key)}')">Try it in playground ‚Üí</button>
        <button class="btn btn-secondary btn-small" onclick="collapseTopic(this)">Collapse</button>
      </div>
    `;
    card.addEventListener('click', function(e) {
      if (e.target.tagName === 'BUTTON' || e.target.tagName === 'A') return;
      if (!this.classList.contains('expanded')) {
        this.classList.add('expanded');
      }
    });
    grid.appendChild(card);
  }
}

window.tryTopic = function(key) {
  const meta = CONCEPT_META[key];
  if (meta) switchTab(meta.tab);
};

window.collapseTopic = function(btn) {
  btn.closest('.explore-card').classList.remove('expanded');
};

window.filterExplore = function() {
  const q = document.getElementById('exploreSearch').value.toLowerCase().trim();
  document.querySelectorAll('#exploreGrid .explore-card').forEach(card => {
    if (!q) { card.style.display = ''; return; }
    const text = card.textContent.toLowerCase();
    card.style.display = text.includes(q) ? '' : 'none';
  });
};

// ‚îÄ‚îÄ Benchmark: Sub-panel switching ‚îÄ‚îÄ
document.querySelectorAll('.bench-panel-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.bench-panel-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.bench-view').forEach(v => v.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('bench-' + btn.dataset.bench).classList.add('active');
  });
});

// ‚îÄ‚îÄ Benchmark: Model checkboxes ‚îÄ‚îÄ
function buildModelCheckboxes() {
  const container = document.getElementById('benchModelChecks');
  container.innerHTML = '';
  const defaults = ['voyage-4-large', 'voyage-4', 'voyage-4-lite'];
  embedModels.forEach(m => {
    const label = document.createElement('label');
    label.style.cssText = 'display:flex;align-items:center;gap:4px;font-size:13px;cursor:pointer;color:var(--text);';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.value = m.name;
    cb.checked = defaults.includes(m.name);
    cb.style.accentColor = 'var(--accent)';
    label.appendChild(cb);
    label.appendChild(document.createTextNode(m.name));
    container.appendChild(label);
  });
}

function populateBenchRankSelects() {
  const selA = document.getElementById('benchRankModelA');
  const selB = document.getElementById('benchRankModelB');
  [selA, selB].forEach(sel => {
    sel.innerHTML = '';
    [...embedModels, ...rerankModels].forEach(m => {
      const opt = document.createElement('option');
      opt.value = m.name;
      opt.textContent = m.name;
      sel.appendChild(opt);
    });
  });
  // Sensible defaults
  if (embedModels.length >= 2) {
    selA.value = embedModels[0].name;
    selB.value = embedModels[embedModels.length > 2 ? 2 : 1].name;
  }
}

// ‚îÄ‚îÄ Benchmark: Latency ‚îÄ‚îÄ
const BENCH_SAMPLE_TEXTS = [
  'MongoDB Atlas provides a fully managed cloud database service with built-in vector search capabilities.',
  'Kubernetes orchestrates containerized applications across clusters of machines for high availability.',
  'Machine learning models transform raw data into embeddings that capture semantic meaning.',
  'RESTful APIs use HTTP methods like GET, POST, PUT, and DELETE to manage resources.',
  'Natural language processing enables computers to understand and generate human language.',
];

const MODEL_COLORS = [
  '#00d4aa', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffd93d',
  '#ff6b6b', '#c792ea', '#f78c6c', '#82aaff', '#c3e88d',
];

window.doBenchLatency = async function() {
  hideError('benchLatencyError');
  const checks = document.querySelectorAll('#benchModelChecks input:checked');
  const models = Array.from(checks).map(c => c.value);
  if (models.length === 0) { showError('benchLatencyError', 'Select at least one model'); return; }

  const rounds = parseInt(document.getElementById('benchRounds').value, 10);
  const customText = document.getElementById('benchLatencyInput').value.trim();
  const texts = customText ? [customText] : BENCH_SAMPLE_TEXTS;

  setLoading('benchLatencyBtn', true);
  document.getElementById('benchLatencyResult').classList.add('visible');

  const chart = document.getElementById('benchLatencyChart');
  const statsEl = document.getElementById('benchLatencyStats');

  // Build placeholder bars
  chart.innerHTML = '';
  models.forEach((model, i) => {
    const row = document.createElement('div');
    row.className = 'latency-row';
    row.innerHTML = `
      <span class="latency-model">${model}</span>
      <div class="latency-bar-outer">
        <div class="latency-bar-inner running" id="bench-bar-${i}" style="background:${MODEL_COLORS[i % MODEL_COLORS.length]}"></div>
      </div>
      <span class="latency-stats" id="bench-stats-${i}">Running...</span>
      <span class="latency-badge" id="bench-badge-${i}"></span>
    `;
    chart.appendChild(row);
  });
  statsEl.innerHTML = `<span class="stat"><span class="stat-label">Texts</span><span class="stat-value">${texts.length}</span></span>
    <span class="stat"><span class="stat-label">Rounds</span><span class="stat-value">${rounds}</span></span>`;

  const results = [];

  for (let mi = 0; mi < models.length; mi++) {
    const model = models[mi];
    const latencies = [];
    let tokens = 0, dims = 0;

    for (let r = 0; r < rounds; r++) {
      try {
        const data = await apiPost('/api/benchmark/embed', { texts, model, inputType: 'document' });
        latencies.push(data.elapsed);
        tokens = data.tokens;
        dims = data.dimensions;
      } catch (err) {
        document.getElementById(`bench-stats-${mi}`).textContent = 'Error';
        document.getElementById(`bench-bar-${mi}`).classList.remove('running');
        document.getElementById(`bench-bar-${mi}`).style.width = '0%';
        break;
      }
    }

    if (latencies.length > 0) {
      const avg = latencies.reduce((a, b) => a + b, 0) / latencies.length;
      const sorted = [...latencies].sort((a, b) => a - b);
      const p50 = sorted[Math.floor(sorted.length / 2)];
      results.push({ model, avg, p50, min: sorted[0], max: sorted[sorted.length - 1], tokens, dims, idx: mi });
    }
  }

  // Animate bars to final widths
  if (results.length > 0) {
    const maxAvg = Math.max(...results.map(r => r.avg));
    const minAvg = Math.min(...results.map(r => r.avg));

    results.forEach(r => {
      const bar = document.getElementById(`bench-bar-${r.idx}`);
      const stats = document.getElementById(`bench-stats-${r.idx}`);
      const badge = document.getElementById(`bench-badge-${r.idx}`);
      bar.classList.remove('running');
      const pct = Math.max(15, (r.avg / maxAvg) * 100);
      bar.style.width = pct + '%';
      bar.textContent = r.avg.toFixed(0) + 'ms';
      stats.textContent = `p50: ${r.p50.toFixed(0)}ms`;
      stats.title = `min: ${r.min.toFixed(0)}ms, max: ${r.max.toFixed(0)}ms`;
      if (r.avg === minAvg) badge.textContent = '‚ö°';
    });

    // Update stats
    const fastest = results.reduce((a, b) => a.avg < b.avg ? a : b);
    const price = getModelPrice(fastest.model);
    statsEl.innerHTML += `
      <span class="stat"><span class="stat-label">Fastest</span><span class="stat-value">${fastest.model}</span></span>
      <span class="stat"><span class="stat-label">Avg</span><span class="stat-value">${fastest.avg.toFixed(0)}ms</span></span>
      <span class="stat"><span class="stat-label">Dims</span><span class="stat-value">${fastest.dims}</span></span>
      ${price ? `<span class="stat"><span class="stat-label">Price</span><span class="stat-value">${price}</span></span>` : ''}
    `;

    // Save to history
    saveBenchHistory(results, texts.length, rounds);
    renderHistory();
  }

  setLoading('benchLatencyBtn', false);
};

function getModelPrice(name) {
  const m = allModels.find(m => m.name === name);
  return m ? m.price : null;
}

function getModelPriceNum(name) {
  const m = allModels.find(m => m.name === name);
  if (!m) return null;
  const match = m.price.match(/\$([0-9.]+)\/1M/);
  return match ? parseFloat(match[1]) : null;
}

// ‚îÄ‚îÄ Benchmark: Ranking Comparison ‚îÄ‚îÄ
window.doBenchRanking = async function() {
  hideError('benchRankError');
  const query = document.getElementById('benchRankQuery').value.trim();
  const docsText = document.getElementById('benchRankDocs').value.trim();
  if (!query || !docsText) { showError('benchRankError', 'Enter a query and documents'); return; }

  const documents = docsText.split('\n').map(d => d.trim()).filter(Boolean);
  if (documents.length < 2) { showError('benchRankError', 'Enter at least 2 documents'); return; }

  const modelA = document.getElementById('benchRankModelA').value;
  const modelB = document.getElementById('benchRankModelB').value;
  const mode = document.getElementById('benchRankMode').value;
  const topK = parseInt(document.getElementById('benchRankTopK').value, 10);

  setLoading('benchRankBtn', true);

  try {
    let rankedA, rankedB;

    if (mode === 'embed') {
      // Embedding similarity mode
      const [dataA, dataB] = await Promise.all([
        apiPost('/api/benchmark/embed', { texts: [query, ...documents], model: modelA, inputType: 'document' }),
        apiPost('/api/benchmark/embed', { texts: [query, ...documents], model: modelB, inputType: 'document' }),
      ]);

      rankedA = rankBySimilarity(dataA.embeddings, documents, topK);
      rankedB = rankBySimilarity(dataB.embeddings, documents, topK);
    } else {
      // Rerank mode
      const [dataA, dataB] = await Promise.all([
        apiPost('/api/benchmark/rerank', { query, documents, model: modelA, topK }),
        apiPost('/api/benchmark/rerank', { query, documents, model: modelB, topK }),
      ]);

      rankedA = dataA.results.slice(0, topK).map(r => ({
        index: r.index,
        text: documents[r.index],
        score: r.relevance_score,
      }));
      rankedB = dataB.results.slice(0, topK).map(r => ({
        index: r.index,
        text: documents[r.index],
        score: r.relevance_score,
      }));
    }

    // Render comparison
    renderRankComparison(modelA, modelB, rankedA, rankedB, topK);
    document.getElementById('benchRankResult').classList.add('visible');
  } catch (err) {
    showError('benchRankError', err.message);
  } finally {
    setLoading('benchRankBtn', false);
  }
};

function rankBySimilarity(embeddings, documents, topK) {
  const queryVec = embeddings[0];
  const docVecs = embeddings.slice(1);
  const scores = docVecs.map((dv, i) => ({
    index: i,
    text: documents[i],
    score: cosineSim(queryVec, dv),
  }));
  scores.sort((a, b) => b.score - a.score);
  return scores.slice(0, topK);
}

function renderRankComparison(modelA, modelB, rankedA, rankedB, topK) {
  const grid = document.getElementById('benchRankGrid');
  const verdict = document.getElementById('benchRankVerdict');
  grid.innerHTML = '';

  // Header
  const header = document.createElement('div');
  header.className = 'rank-row';
  header.style.background = 'none';
  header.style.fontWeight = '600';
  header.style.fontSize = '13px';
  header.style.color = 'var(--accent)';
  header.innerHTML = `<div></div><div>${modelA}</div><div></div><div>${modelB}</div>`;
  grid.appendChild(header);

  const orderA = rankedA.map(r => r.index);
  const orderB = rankedB.map(r => r.index);
  let matches = 0;

  const k = Math.min(topK, rankedA.length, rankedB.length);
  for (let i = 0; i < k; i++) {
    const a = rankedA[i];
    const b = rankedB[i];
    const same = a.index === b.index;
    if (same) matches++;

    const truncA = a.text.length > 60 ? a.text.slice(0, 57) + '...' : a.text;
    const truncB = b.text.length > 60 ? b.text.slice(0, 57) + '...' : b.text;

    const row = document.createElement('div');
    row.className = 'rank-row';
    row.innerHTML = `
      <div class="rank-num">${i + 1}</div>
      <div class="rank-item ${same ? 'rank-match' : 'rank-differ'}">
        <div title="${a.text.replace(/"/g, '&quot;')}">${truncA}</div>
        <div class="rank-score">${a.score.toFixed(4)} [doc ${a.index}]</div>
      </div>
      <div class="rank-arrow">${same ? '=' : '‚â†'}</div>
      <div class="rank-item ${same ? 'rank-match' : 'rank-differ'}">
        <div title="${b.text.replace(/"/g, '&quot;')}">${truncB}</div>
        <div class="rank-score">${b.score.toFixed(4)} [doc ${b.index}]</div>
      </div>
    `;
    grid.appendChild(row);
  }

  // Compute overlap
  const setA = new Set(orderA.slice(0, k));
  const setB = new Set(orderB.slice(0, k));
  const overlap = [...setA].filter(x => setB.has(x)).length;
  const overlapPct = ((overlap / k) * 100).toFixed(0);
  const agreePct = ((matches / k) * 100).toFixed(0);

  if (matches === k) {
    verdict.innerHTML = `<span style="color:var(--green)">‚úì Models agree on all ${k} positions ‚Äî the cheaper model is likely sufficient.</span>`;
  } else if (overlap === k) {
    verdict.innerHTML = `<span style="color:var(--yellow)">‚ö† Same ${k} documents in top-${k}, but in different order (${agreePct}% exact match).</span>`;
  } else {
    verdict.innerHTML = `<span style="color:var(--warning)">‚ö† ${overlapPct}% overlap in top-${k} results ‚Äî models see different relevance signals.</span>`;
  }
}

// ‚îÄ‚îÄ Benchmark: Quantization ‚îÄ‚îÄ
function populateQuantModelSelect() {
  const sel = document.getElementById('quantModel');
  sel.innerHTML = '';
  embedModels.forEach(m => {
    const opt = document.createElement('option');
    opt.value = m.name;
    opt.textContent = m.name;
    sel.appendChild(opt);
  });
  // Default to voyage-4-large if available
  const preferred = embedModels.find(m => m.name === 'voyage-4-large');
  if (preferred) sel.value = preferred.name;
}

function hammingSimUI(a, b) {
  // For binary/ubinary packed embeddings, compute agreement via dot product
  let dot = 0;
  for (let i = 0; i < a.length; i++) dot += a[i] * b[i];
  return dot;
}

window.doBenchQuantization = async function() {
  hideError('quantError');
  const model = document.getElementById('quantModel').value;
  const dimsVal = document.getElementById('quantDimensions').value;
  const dimensions = dimsVal ? parseInt(dimsVal, 10) : undefined;
  const query = document.getElementById('quantQuery').value.trim();
  const corpusText = document.getElementById('quantCorpus').value.trim();

  if (!query) { showError('quantError', 'Enter a query'); return; }
  if (!corpusText) { showError('quantError', 'Enter at least 2 documents'); return; }

  const corpus = corpusText.split('\n').map(d => d.trim()).filter(Boolean);
  if (corpus.length < 2) { showError('quantError', 'Enter at least 2 documents'); return; }

  const checks = document.querySelectorAll('#quantDtypeChecks input:checked');
  const dtypes = Array.from(checks).map(c => c.value);
  if (dtypes.length === 0) { showError('quantError', 'Select at least one data type'); return; }

  setLoading('quantBtn', true);

  try {
    const allTexts = [query, ...corpus];
    const resultsByDtype = {};

    for (const dtype of dtypes) {
      const body = { texts: allTexts, model, inputType: 'document' };
      if (dimensions) body.dimensions = dimensions;
      if (dtype !== 'float') body.output_dtype = dtype;

      const start = performance.now();
      const data = await apiPost('/api/embed', body);
      const elapsed = performance.now() - start;

      const embeddings = data.data.map(d => d.embedding);
      const queryEmbed = embeddings[0];
      const dims = embeddings[0].length;
      const isBinary = (dtype === 'binary' || dtype === 'ubinary');

      // Rank corpus documents by similarity
      const ranked = corpus.map((text, i) => {
        const docEmbed = embeddings[i + 1];
        let sim;
        if (isBinary) {
          sim = hammingSimUI(queryEmbed, docEmbed);
        } else {
          sim = cosineSim(queryEmbed, docEmbed);
        }
        return { index: i, text, similarity: sim };
      }).sort((a, b) => b.similarity - a.similarity);

      // Calculate storage
      const actualDims = isBinary ? dims * 8 : dims;
      let bytesPerVec;
      if (dtype === 'float') bytesPerVec = dims * 4;
      else if (dtype === 'int8' || dtype === 'uint8') bytesPerVec = dims * 1;
      else bytesPerVec = dims; // binary/ubinary: dims is already 1/8th

      resultsByDtype[dtype] = {
        dtype, latency: elapsed, dims, actualDims, bytesPerVec,
        tokens: data.usage?.total_tokens || 0, ranked,
      };
    }

    const completed = Object.values(resultsByDtype);
    if (completed.length === 0) {
      showError('quantError', 'No data types completed successfully');
      return;
    }

    // ‚îÄ‚îÄ Render Charts ‚îÄ‚îÄ
    const baseline = completed.find(r => r.dtype === 'float') || completed[0];
    const maxBytes = Math.max(...completed.map(r => r.bytesPerVec));
    const maxLatency = Math.max(...completed.map(r => r.latency));
    const DTYPE_COLORS = { float: '#00d4aa', int8: '#4ecdc4', uint8: '#45b7d1', ubinary: '#ffd93d', binary: '#ff6b6b' };

    // ‚îÄ‚îÄ Storage Bar Chart ‚îÄ‚îÄ
    let storageHTML = '';
    for (const r of completed) {
      const pct = Math.max(8, (r.bytesPerVec / maxBytes) * 100);
      const totalMB = (r.bytesPerVec * 1_000_000) / (1024 * 1024);
      const sizeStr = totalMB >= 1024 ? `${(totalMB / 1024).toFixed(1)} GB` : `${totalMB.toFixed(0)} MB`;
      const savings = r.bytesPerVec < baseline.bytesPerVec
        ? `${(baseline.bytesPerVec / r.bytesPerVec).toFixed(0)}√ó smaller`
        : 'baseline';
      const color = DTYPE_COLORS[r.dtype] || '#82aaff';
      storageHTML += `<div class="quant-bar-group">
        <div class="quant-bar-label">
          <span class="dtype-name">${r.dtype}</span>
          <span class="dtype-value">${formatBytesUI(r.bytesPerVec)}/vec ¬∑ ${sizeStr} @ 1M</span>
        </div>
        <div class="quant-bar-track">
          <div class="quant-bar-fill storage" style="width:${pct}%;background:linear-gradient(90deg, ${color}, ${color}cc);">${savings}</div>
        </div>
      </div>`;
    }
    document.getElementById('quantStorageChart').innerHTML = storageHTML;

    // ‚îÄ‚îÄ Latency Bar Chart ‚îÄ‚îÄ
    let latencyHTML = '';
    const minLatency = Math.min(...completed.map(r => r.latency));
    for (const r of completed) {
      const pct = Math.max(8, (r.latency / maxLatency) * 100);
      const color = DTYPE_COLORS[r.dtype] || '#82aaff';
      const badge = r.latency === minLatency ? ' ‚ö°' : '';
      latencyHTML += `<div class="quant-bar-group">
        <div class="quant-bar-label">
          <span class="dtype-name">${r.dtype}</span>
          <span class="dtype-value">${r.latency.toFixed(0)}ms${badge}</span>
        </div>
        <div class="quant-bar-track">
          <div class="quant-bar-fill latency" style="width:${pct}%;background:linear-gradient(90deg, ${color}, ${color}cc);">${r.latency.toFixed(0)}ms</div>
        </div>
      </div>`;
    }
    document.getElementById('quantLatencyChart').innerHTML = latencyHTML;

    // ‚îÄ‚îÄ Quality Meters + Ranking Grid ‚îÄ‚îÄ
    const topK = Math.min(5, corpus.length);
    const metersEl = document.getElementById('quantQualityMeters');
    const gridEl = document.getElementById('quantRankGrid');
    gridEl.innerHTML = '';
    metersEl.innerHTML = '';

    if (completed.length >= 2 && baseline) {
      const baselineRanking = baseline.ranked.slice(0, topK).map(r => r.index);

      // Quality meters for each non-baseline dtype
      let metersHTML = '';
      for (const r of completed) {
        if (r.dtype === baseline.dtype) continue;
        const otherRanking = r.ranked.slice(0, topK).map(x => x.index);
        const overlap = baselineRanking.filter(idx => otherRanking.includes(idx)).length;
        const overlapPct = (overlap / topK) * 100;
        const exactMatch = baselineRanking.every((idx, pos) => otherRanking[pos] === idx);
        const positionMatches = baselineRanking.filter((idx, pos) => otherRanking[pos] === idx).length;
        const posMatchPct = (positionMatches / topK) * 100;

        let grade, gradeLabel, detail;
        if (exactMatch) {
          grade = 'perfect'; gradeLabel = '‚úì Perfect';
          detail = `Identical ranking ‚Äî all ${topK} positions match float baseline`;
        } else if (overlap === topK) {
          grade = 'good'; gradeLabel = '‚âà Reordered';
          detail = `Same ${topK} documents, ${positionMatches}/${topK} in same position`;
        } else {
          grade = overlap >= topK * 0.6 ? 'good' : 'degraded';
          gradeLabel = `${overlapPct.toFixed(0)}% overlap`;
          detail = `${overlap}/${topK} documents match, ${positionMatches}/${topK} positions match`;
        }

        metersHTML += `<div class="quant-quality-meter">
          <div class="quant-meter-header">
            <span class="dtype-name">${r.dtype}</span>
            <span class="verdict-badge ${grade}">${gradeLabel}</span>
          </div>
          <div class="quant-meter-track">
            <div class="quant-meter-fill ${grade}" style="width:${exactMatch ? 100 : posMatchPct}%"></div>
          </div>
          <div class="quant-meter-detail">${detail}</div>
        </div>`;
      }
      metersEl.innerHTML = metersHTML;

      // Side-by-side ranking columns
      let rankHTML = `<div class="quant-rank-cols" style="grid-template-columns:repeat(${completed.length},1fr);">`;
      for (const r of completed) {
        rankHTML += `<div><div class="quant-rank-col-header">${r.dtype}${r === baseline ? ' (baseline)' : ''}</div>`;
        r.ranked.slice(0, topK).forEach((item, pos) => {
          const trunc = item.text.length > 55 ? item.text.slice(0, 52) + '‚Ä¶' : item.text;
          let cls = 'baseline';
          if (r !== baseline) {
            cls = (baseline.ranked[pos] && item.index === baseline.ranked[pos].index) ? 'match' : 'differ';
          }
          rankHTML += `<div class="quant-rank-item ${cls}" title="${item.text.replace(/"/g, '&quot;')}">
            <span class="quant-rank-pos">${pos + 1}</span>${trunc}
            <div class="quant-rank-score">${item.similarity.toFixed(4)} ¬∑ doc ${item.index}</div>
          </div>`;
        });
        rankHTML += '</div>';
      }
      rankHTML += '</div>';
      gridEl.innerHTML = rankHTML;
    } else {
      metersEl.innerHTML = '<span style="color:var(--text-dim)">Select multiple data types (including float) to compare rankings.</span>';
    }

    document.getElementById('quantResult').classList.add('visible');
  } catch (err) {
    showError('quantError', err.message);
  } finally {
    setLoading('quantBtn', false);
  }
};

// ‚îÄ‚îÄ Benchmark: Cost Calculator ‚îÄ‚îÄ
// ‚îÄ‚îÄ Cost Calculator: Shared Helpers ‚îÄ‚îÄ

function costFormatDollars(n) {
  if (n === 0) return '$0.00';
  if (n < 0.01 && n > 0) return '$' + n.toFixed(4);
  if (n < 1) return '$' + n.toFixed(2);
  return '$' + n.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
}

function costShortNum(n) {
  if (n >= 1e9) return (n / 1e9).toFixed(n % 1e9 === 0 ? 0 : 1) + 'B';
  if (n >= 1e6) return (n / 1e6).toFixed(n % 1e6 === 0 ? 0 : 1) + 'M';
  if (n >= 1e3) return (n / 1e3).toFixed(n % 1e3 === 0 ? 0 : 1) + 'K';
  return String(n);
}

function costGetPricePerM(model) {
  const match = model.price.match(/\$([0-9.]+)\/1M/);
  return match ? parseFloat(match[1]) : null;
}

function costGetV4Models() {
  return allModels.filter(m => !m.legacy && !m.unreleased && costGetPricePerM(m) !== null);
}

// ‚îÄ‚îÄ Cost Mode Toggle ‚îÄ‚îÄ

let currentCostMode = 'simple';

function setCostMode(mode) {
  currentCostMode = mode;
  document.querySelectorAll('.cost-mode-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.mode === mode);
  });
  document.getElementById('costSimpleMode').style.display = mode === 'simple' ? '' : 'none';
  document.getElementById('costRagMode').style.display = mode === 'rag' ? '' : 'none';
  if (mode === 'rag') updateRagCalculator();
}

// ‚îÄ‚îÄ Simple Mode (query-only comparison) ‚îÄ‚îÄ

function initCostCalculator() {
  // Mode toggle buttons
  document.getElementById('costModeSimple').addEventListener('click', () => setCostMode('simple'));
  document.getElementById('costModeRag').addEventListener('click', () => setCostMode('rag'));

  // Help modal
  const helpModal = document.getElementById('costHelpModal');
  document.getElementById('costHelpBtn').addEventListener('click', () => helpModal.classList.add('open'));
  document.getElementById('costHelpClose').addEventListener('click', () => helpModal.classList.remove('open'));
  helpModal.addEventListener('click', (e) => { if (e.target === helpModal) helpModal.classList.remove('open'); });
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape') helpModal.classList.remove('open'); });

  // Simple mode sliders
  const tokSlider = document.getElementById('costTokens');
  const qSlider = document.getElementById('costQueries');
  const tokValue = document.getElementById('costTokensValue');
  const qValue = document.getElementById('costQueriesValue');

  function updateCost() {
    const tokens = parseInt(tokSlider.value, 10);
    const queries = parseInt(qSlider.value, 10);
    tokValue.textContent = tokens.toLocaleString();
    qValue.textContent = queries.toLocaleString();
    renderCostTable(tokens, queries);
  }

  tokSlider.addEventListener('input', updateCost);
  qSlider.addEventListener('input', updateCost);
  updateCost();

  // RAG mode init
  initRagCalculator();
}

function renderCostTable(tokensPerQuery, queriesPerDay) {
  const tbody = document.getElementById('costTableBody');
  tbody.innerHTML = '';

  const models = allModels.filter(m => !m.legacy && !m.unreleased);
  const rows = [];

  models.forEach(m => {
    const pricePerM = costGetPricePerM(m);
    if (pricePerM === null) return;
    const dailyTokens = tokensPerQuery * queriesPerDay;
    const dailyCost = (dailyTokens / 1_000_000) * pricePerM;
    const monthlyCost = dailyCost * 30;
    rows.push({ name: m.name, type: m.type === 'embedding' ? 'embed' : 'rerank', pricePerM, dailyCost, monthlyCost });
  });

  rows.sort((a, b) => a.monthlyCost - b.monthlyCost);
  const maxMonthly = Math.max(...rows.map(r => r.monthlyCost), 0.01);

  rows.forEach(r => {
    const tr = document.createElement('tr');
    const barPct = Math.max(2, (r.monthlyCost / maxMonthly) * 100);
    const monthlyStr = r.monthlyCost < 0.01 ? '<$0.01' : '$' + (r.monthlyCost < 1 ? r.monthlyCost.toFixed(2) : r.monthlyCost < 100 ? r.monthlyCost.toFixed(1) : r.monthlyCost.toFixed(0));
    const dailyStr = r.dailyCost < 0.01 ? '<$0.01' : '$' + r.dailyCost.toFixed(2);

    tr.innerHTML = `
      <td style="color:var(--text)">${r.name}</td>
      <td style="color:var(--text-dim)">${r.type}</td>
      <td>$${r.pricePerM.toFixed(2)}</td>
      <td>${dailyStr}</td>
      <td class="cost-highlight">${monthlyStr}</td>
      <td class="cost-bar-cell" style="position:relative;padding-left:8px;">
        <div class="cost-bar" style="width:${barPct}%;"></div>
        <span style="position:relative;z-index:1;font-size:12px;color:var(--text-dim);">${monthlyStr}</span>
      </td>
    `;
    tbody.appendChild(tr);
  });
}

// ‚îÄ‚îÄ RAG Planner Mode (full TCO with strategies) ‚îÄ‚îÄ

function initRagCalculator() {
  // Populate model dropdowns
  const embeddingModels = allModels.filter(m =>
    m.type === 'embedding' && !m.legacy && !m.unreleased && costGetPricePerM(m) !== null
  );

  const docSelect = document.getElementById('ragDocModel');
  const querySelect = document.getElementById('ragQueryModel');

  embeddingModels.forEach(m => {
    const pricePerM = costGetPricePerM(m);
    const opt1 = document.createElement('option');
    opt1.value = m.name;
    opt1.textContent = `${m.name} ($${pricePerM.toFixed(2)}/1M)`;
    docSelect.appendChild(opt1);

    const opt2 = document.createElement('option');
    opt2.value = m.name;
    opt2.textContent = `${m.name} ($${pricePerM.toFixed(2)}/1M)`;
    querySelect.appendChild(opt2);
  });

  // Set defaults: voyage-4-large for docs, voyage-4-lite for queries
  docSelect.value = 'voyage-4-large';
  querySelect.value = 'voyage-4-lite';

  // Bind all sliders and selects
  const ids = ['ragDocs', 'ragDocTokens', 'ragQueries', 'ragQueryTokens', 'ragMonths'];
  ids.forEach(id => {
    document.getElementById(id).addEventListener('input', updateRagCalculator);
  });
  docSelect.addEventListener('change', updateRagCalculator);
  querySelect.addEventListener('change', updateRagCalculator);

  updateRagCalculator();
}

function updateRagCalculator() {
  const numDocs = parseInt(document.getElementById('ragDocs').value, 10);
  const docTokens = parseInt(document.getElementById('ragDocTokens').value, 10);
  const numQueries = parseInt(document.getElementById('ragQueries').value, 10);
  const queryTokens = parseInt(document.getElementById('ragQueryTokens').value, 10);
  const months = parseInt(document.getElementById('ragMonths').value, 10);
  const docModelName = document.getElementById('ragDocModel').value;
  const queryModelName = document.getElementById('ragQueryModel').value;

  // Update slider display values
  document.getElementById('ragDocsValue').textContent = costShortNum(numDocs);
  document.getElementById('ragDocTokensValue').textContent = docTokens.toLocaleString();
  document.getElementById('ragQueriesValue').textContent = costShortNum(numQueries);
  document.getElementById('ragQueryTokensValue').textContent = queryTokens.toLocaleString();
  document.getElementById('ragMonthsValue').textContent = months + ' mo';

  const docTotalTokens = numDocs * docTokens;
  const queryTotalTokensPerMonth = numQueries * queryTokens;

  // Get model prices
  const docModel = allModels.find(m => m.name === docModelName);
  const queryModel = allModels.find(m => m.name === queryModelName);
  const docPrice = docModel ? costGetPricePerM(docModel) : 0;
  const queryPrice = queryModel ? costGetPricePerM(queryModel) : 0;

  // ‚îÄ‚îÄ Build strategies (same logic as CLI) ‚îÄ‚îÄ
  const strategies = [];
  const v4Embedding = allModels.filter(m =>
    m.type === 'embedding' && !m.legacy && !m.unreleased &&
    (m.sharedSpace === 'voyage-4' || m.name.startsWith('voyage-4')) &&
    costGetPricePerM(m) !== null && costGetPricePerM(m) > 0
  );

  // Strategy group 1: Symmetric with each V4 model
  v4Embedding.forEach(m => {
    const price = costGetPricePerM(m);
    const docCost = (docTotalTokens / 1e6) * price;
    const queryCostPerMonth = (queryTotalTokensPerMonth / 1e6) * price;
    const totalCost = docCost + (queryCostPerMonth * months);
    strategies.push({
      name: `Symmetric: ${m.name}`,
      type: 'symmetric',
      docModel: m.name,
      queryModel: m.name,
      docCost,
      queryCostPerMonth,
      totalCost,
      months,
    });
  });

  // Strategy 2: Asymmetric ‚Äî user-selected combo
  const asymDocCost = (docTotalTokens / 1e6) * docPrice;
  const asymQueryCostPerMonth = (queryTotalTokensPerMonth / 1e6) * queryPrice;
  const asymTotalCost = asymDocCost + (asymQueryCostPerMonth * months);

  // Only add if it's actually asymmetric (different models)
  if (docModelName !== queryModelName) {
    strategies.push({
      name: `Asymmetric: ${docModelName} + ${queryModelName}`,
      type: 'asymmetric',
      docModel: docModelName,
      queryModel: queryModelName,
      docCost: asymDocCost,
      queryCostPerMonth: asymQueryCostPerMonth,
      totalCost: asymTotalCost,
      months,
      recommended: true,
    });
  }

  // Strategy 3: Asymmetric with nano (local, free queries)
  strategies.push({
    name: `Asymmetric: ${docModelName} + nano (local)`,
    type: 'asymmetric-local',
    docModel: docModelName,
    queryModel: 'voyage-4-nano',
    docCost: asymDocCost,
    queryCostPerMonth: 0,
    totalCost: asymDocCost,
    months,
    localNote: 'Query cost = $0 (runs locally via HuggingFace)',
  });

  strategies.sort((a, b) => a.totalCost - b.totalCost);
  const maxCost = Math.max(...strategies.map(s => s.totalCost), 0.01);

  // ‚îÄ‚îÄ Render summary cards ‚îÄ‚îÄ
  const summaryEl = document.getElementById('ragSummary');
  summaryEl.innerHTML = `
    <div class="cost-summary-card">
      <div class="cost-summary-label">Document tokens</div>
      <div class="cost-summary-value">${costShortNum(docTotalTokens)}</div>
      <div class="cost-summary-detail">${costShortNum(numDocs)} docs √ó ${docTokens.toLocaleString()} tok</div>
    </div>
    <div class="cost-summary-card">
      <div class="cost-summary-label">Query tokens / mo</div>
      <div class="cost-summary-value">${costShortNum(queryTotalTokensPerMonth)}</div>
      <div class="cost-summary-detail">${costShortNum(numQueries)} queries √ó ${queryTokens} tok</div>
    </div>
    <div class="cost-summary-card">
      <div class="cost-summary-label">Best ${months}-mo total</div>
      <div class="cost-summary-value">${costFormatDollars(strategies[0].totalCost)}</div>
      <div class="cost-summary-detail">${strategies[0].name}</div>
    </div>
    <div class="cost-summary-card">
      <div class="cost-summary-label">Max potential savings</div>
      <div class="cost-summary-value" style="color:#4ade80">${maxCost > 0 ? ((1 - strategies[0].totalCost / maxCost) * 100).toFixed(0) + '%' : '0%'}</div>
      <div class="cost-summary-detail">vs ${strategies[strategies.length - 1].name.split(':')[1]?.trim() || 'most expensive'}</div>
    </div>
  `;

  // ‚îÄ‚îÄ Render strategy cards ‚îÄ‚îÄ
  const stratEl = document.getElementById('ragStrategies');
  stratEl.innerHTML = strategies.map(s => {
    const savings = maxCost > 0 ? ((1 - s.totalCost / maxCost) * 100) : 0;
    const savingsHtml = savings > 0 ? `<div class="cost-savings">‚Üì ${savings.toFixed(0)}% savings</div>` : '';
    const badgeHtml = s.recommended ? '<div class="cost-strategy-badge">‚òÖ Recommended</div>' : '';
    const localHtml = s.localNote ? `<div style="font-size:11px;color:var(--text-muted);margin-top:6px;">‚ö° ${s.localNote}</div>` : '';

    return `
      <div class="cost-strategy${s.recommended ? ' recommended' : ''}">
        ${badgeHtml}
        <div class="cost-strategy-name">${s.name}</div>
        <div class="cost-strategy-row">
          <span class="cost-strategy-row-label">Doc embedding</span>
          <span class="cost-strategy-row-value">${costFormatDollars(s.docCost)} <span style="color:var(--text-muted);font-size:11px">(one-time)</span></span>
        </div>
        <div class="cost-strategy-row">
          <span class="cost-strategy-row-label">Query cost</span>
          <span class="cost-strategy-row-value">${costFormatDollars(s.queryCostPerMonth)}/mo</span>
        </div>
        <div class="cost-strategy-total">
          <span class="cost-strategy-total-label">${s.months}-month total</span>
          <span class="cost-strategy-total-value">${costFormatDollars(s.totalCost)}</span>
        </div>
        ${savingsHtml}
        ${localHtml}
      </div>
    `;
  }).join('');

  // ‚îÄ‚îÄ Render per-model table ‚îÄ‚îÄ
  const ragTbody = document.getElementById('ragTableBody');
  ragTbody.innerHTML = '';

  const allEmbedding = allModels.filter(m =>
    m.type === 'embedding' && !m.legacy && !m.unreleased && costGetPricePerM(m) !== null && costGetPricePerM(m) > 0
  );

  const tableRows = allEmbedding.map(m => {
    const price = costGetPricePerM(m);
    const dCost = (docTotalTokens / 1e6) * price;
    const qCostMo = (queryTotalTokensPerMonth / 1e6) * price;
    const total = dCost + (qCostMo * months);
    return { name: m.name, dCost, qCostMo, total };
  }).sort((a, b) => a.total - b.total);

  const maxTable = Math.max(...tableRows.map(r => r.total), 0.01);

  tableRows.forEach(r => {
    const tr = document.createElement('tr');
    const barPct = Math.max(2, (r.total / maxTable) * 100);
    tr.innerHTML = `
      <td style="color:var(--text)">${r.name}</td>
      <td>${costFormatDollars(r.dCost)}</td>
      <td>${costFormatDollars(r.qCostMo)}</td>
      <td class="cost-highlight">${costFormatDollars(r.total)}</td>
      <td class="cost-bar-cell" style="position:relative;padding-left:8px;">
        <div class="cost-bar" style="width:${barPct}%;"></div>
        <span style="position:relative;z-index:1;font-size:12px;color:var(--text-dim);">${costFormatDollars(r.total)}</span>
      </td>
    `;
    ragTbody.appendChild(tr);
  });

  // ‚îÄ‚îÄ Tip ‚îÄ‚îÄ
  const bestSym = strategies.find(s => s.type === 'symmetric' && s.docModel === 'voyage-4-large');
  const bestAsym = strategies.find(s => s.recommended);
  const tipEl = document.getElementById('ragTip');
  if (bestSym && bestAsym && bestSym.totalCost > bestAsym.totalCost) {
    const saved = bestSym.totalCost - bestAsym.totalCost;
    const pct = ((saved / bestSym.totalCost) * 100).toFixed(0);
    tipEl.innerHTML = `üí° <strong>Asymmetric retrieval saves ${costFormatDollars(saved)} (${pct}%)</strong> over symmetric voyage-4-large ‚Äî same document quality, lower query costs. The shared embedding space makes this possible. <code>vai explain shared-space</code>`;
  } else {
    tipEl.innerHTML = 'üí° Try selecting different doc and query models to see asymmetric cost savings. <code>vai explain shared-space</code>';
  }
}

// ‚îÄ‚îÄ Benchmark: History ‚îÄ‚îÄ
const HISTORY_KEY = 'vai-bench-history';

function saveBenchHistory(results, textCount, rounds) {
  const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
  history.push({
    timestamp: Date.now(),
    textCount,
    rounds,
    results: results.map(r => ({ model: r.model, avg: r.avg, p50: r.p50, dims: r.dims })),
  });
  // Keep last 20
  if (history.length > 20) history.splice(0, history.length - 20);
  localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
}

function renderHistory() {
  const container = document.getElementById('benchHistoryContent');
  const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');

  if (history.length === 0) {
    container.innerHTML = '<div class="history-empty">No benchmarks recorded yet. Run a latency benchmark to start tracking.</div>';
    return;
  }

  // Collect all models that appear
  const modelSet = new Set();
  history.forEach(h => h.results.forEach(r => modelSet.add(r.model)));
  const models = [...modelSet];
  const colorMap = {};
  models.forEach((m, i) => { colorMap[m] = MODEL_COLORS[i % MODEL_COLORS.length]; });

  // Find global max for scale
  const maxAvg = Math.max(...history.flatMap(h => h.results.map(r => r.avg)));

  let html = '<div class="history-chart">';
  history.forEach((h, hi) => {
    html += '<div class="history-bar-group" title="' + new Date(h.timestamp).toLocaleString() + '">';
    models.forEach(m => {
      const r = h.results.find(r => r.model === m);
      const height = r ? Math.max(4, (r.avg / maxAvg) * 100) : 0;
      const label = r ? `${m}: ${r.avg.toFixed(0)}ms` : '';
      html += `<div class="history-bar" style="height:${height}%;background:${colorMap[m]};" title="${label}"></div>`;
    });
    html += '</div>';
  });
  html += '</div>';

  // Legend
  html += '<div class="history-legend">';
  models.forEach(m => {
    html += `<span><span class="history-legend-dot" style="background:${colorMap[m]}"></span>${m}</span>`;
  });
  html += '</div>';

  // Time labels
  if (history.length > 1) {
    const first = new Date(history[0].timestamp);
    const last = new Date(history[history.length - 1].timestamp);
    html += `<div class="history-labels"><span>${first.toLocaleDateString()} ${first.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}</span><span>${last.toLocaleDateString()} ${last.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}</span></div>`;
  }

  container.innerHTML = html;
}

window.clearHistory = function() {
  localStorage.removeItem(HISTORY_KEY);
  renderHistory();
};

// ‚îÄ‚îÄ Patch init to include benchmark setup ‚îÄ‚îÄ
const _origInit = init;
init = async function() {
  await _origInit();
  buildModelCheckboxes();
  populateBenchRankSelects();
  populateQuantModelSelect();
  initCostCalculator();
  renderHistory();
};

// ‚îÄ‚îÄ Start ‚îÄ‚îÄ
init();
})();
</script>
<!-- Cost Help Modal -->
<div class="cost-modal-overlay" id="costHelpModal">
  <div class="cost-modal">
    <button class="cost-modal-close" id="costHelpClose">&times;</button>

    <h2>üìê How the Cost Calculator Works</h2>

    <p>Voyage AI charges per <strong>million tokens</strong> processed. A token is roughly ¬æ of a word.
    The calculator estimates your total embedding cost based on how many documents you embed
    and how many queries you run over time.</p>

    <h3>üí° Simple Mode</h3>
    <p>Compares the per-model query cost for a given volume. Useful for quick "which model is cheapest?" checks.</p>
    <div class="formula">
      <span class="label">Daily cost =</span><br>
      <span class="accent">tokens_per_query</span> √ó <span class="accent">queries_per_day</span> √∑ 1,000,000 √ó <span class="accent">price_per_M_tokens</span><br><br>
      <span class="label">Monthly cost =</span> daily cost √ó 30
    </div>

    <h3>üìä RAG Planner Mode</h3>
    <p>Models the full cost of a Retrieval-Augmented Generation (RAG) pipeline, separating
    the <strong>one-time</strong> document ingestion cost from the <strong>recurring</strong> query cost.</p>

    <div class="formula">
      <span class="label">Document embedding (one-time):</span><br>
      <span class="accent">doc_cost</span> = num_docs √ó tokens_per_doc √∑ 1,000,000 √ó <span class="accent">doc_model_price</span><br><br>
      <span class="label">Query embedding (monthly):</span><br>
      <span class="accent">query_cost/mo</span> = queries_per_month √ó tokens_per_query √∑ 1,000,000 √ó <span class="accent">query_model_price</span><br><br>
      <span class="label">Projected total:</span><br>
      <span class="accent">total</span> = doc_cost + (query_cost/mo √ó <span class="accent">months</span>)
    </div>

    <h3>‚öñÔ∏è Three Strategies Compared</h3>
    <ul>
      <li><strong>Symmetric</strong> ‚Äî same model for documents and queries. Simple but expensive at scale,
      because query-heavy workloads pay the full model price on every request.</li>
      <li><strong>Asymmetric (‚òÖ Recommended)</strong> ‚Äî use a high-quality model (e.g. <code>voyage-4-large</code>)
      for documents and a cheaper model (e.g. <code>voyage-4-lite</code>) for queries.
      This works because Voyage 4 models share the same embedding space ‚Äî vectors from different
      models are directly comparable.</li>
      <li><strong>Asymmetric + Local</strong> ‚Äî embed documents via the API, but run queries locally using
      <code>voyage-4-nano</code> on HuggingFace (free). Query cost drops to $0.</li>
    </ul>

    <h3>üîó Shared Embedding Space</h3>
    <p>The Voyage 4 family (<code>voyage-4-large</code>, <code>voyage-4</code>, <code>voyage-4-lite</code>,
    <code>voyage-4-nano</code>) all produce vectors in the <em>same geometric space</em>.
    A document embedded with <code>voyage-4-large</code> can be searched with a query embedded by
    <code>voyage-4-lite</code> ‚Äî cosine similarity still works correctly. This is what makes
    asymmetric strategies possible.</p>

    <div class="example">
      <strong>Example:</strong> 100K docs √ó 500 tok = 50M doc tokens<br>
      1M queries/mo √ó 30 tok = 30M query tokens/mo<br><br>
      <strong>Symmetric</strong> (voyage-4-large @ $0.18/1M):<br>
      &nbsp;&nbsp;Docs: $9.00 + Queries: $5.40/mo √ó 12 = <strong>$73.80</strong><br><br>
      <strong>Asymmetric</strong> (large docs + lite queries @ $0.05/1M):<br>
      &nbsp;&nbsp;Docs: $9.00 + Queries: $1.50/mo √ó 12 = <strong>$27.00</strong><br><br>
      &nbsp;&nbsp;Savings: <strong>63%</strong> ‚Äî same document quality, cheaper queries.
    </div>

    <h3>üìã Per-Model Table</h3>
    <p>The bottom table shows what it would cost to use each model symmetrically (same model for
    docs and queries). The relative bar shows cost compared to the most expensive option.
    Use this to understand the price spread across the full model lineup.</p>

    <h3>üéØ Key Assumptions</h3>
    <ul>
      <li>Token counts are estimates ‚Äî actual counts depend on your text. Use <code>vai chunk --stats</code> to measure real token counts.</li>
      <li>Document embedding is a one-time cost (you embed once, search many times).</li>
      <li>Re-embedding (e.g. updated docs) is not modeled ‚Äî add a buffer if your corpus changes frequently.</li>
      <li>Reranking costs are separate and not included here. Reranking is priced per query pair, not per token.</li>
    </ul>

    <p style="margin-top:20px;font-size:12px;color:var(--text-muted);">
      CLI equivalent: <code>vai estimate --docs 100K --queries 1M --doc-model voyage-4-large --query-model voyage-4-lite</code>
    </p>
  </div>
</div>
</body>
</html>
